\chapter{Анализ подходов к построению подсистем AAA в микросервисных архитектурах}\label{ch:1}

% распределенных


Микросервисная архитектура стала доминирующим подходом к построению распределенных систем,
обеспечивая высокую степень масштабируемости, отказоустойчивости и гибкости разработки.
В отличие от монолитных приложений, где все компоненты тесно связаны и развертываются как единое целое,
микросервисы представляют собой набор небольших независимых сервисов,
каждый из которых выполняет определенную бизнес-функцию и может разрабатываться,
развертываться и масштабироваться независимо~\cite{Glumov2024}.

Однако такая распределенность системы создает значимые препятствия в области информационной безопасности.
Каждый микросервис становится потенциальной точкой входа для злоумышленника,
увеличивая поверхность атаки по сравнению с монолитными системами.
Если в монолите необходимо защитить одну точку входа и одну кодовую базу,
то в микросервисной архитектуре требуется индивидуальное внимание к безопасности каждого сервиса,
что значительно усложняет процесс разработки и поддержки.
При этом микросервисы взаимодействуют друг с другом по сети,
что требует реализации безопасной межсервисной коммуникации и правильного управления доверием между компонентами системы~\cite{Almeida2022}.

В этой главе проводится анализ существующих подходов и решений для построения подсистем AAA в микросервисных архитектурах.
В разделе~\ref{sec:1.1} рассматриваются основные решения для пользовательской и межсервисной аутентификации, а также подходы к логированию и аудиту.
Раздел~\ref{sec:1.2} посвящен выделению критериев сравнения и подбору инструментальных средств на их основе.
В разделе~\ref{sec:1.3} формулируются постановка задачи и гипотезы исследования.
Завершает главу раздел~\ref{sec:1.4} с выводами по проведенному анализу.


\section{Обзор имеющихся решений и исследований}\label{sec:1.1}

\subsection{Пользовательская аутентификация и авторизация}\label{subsec:1.1.2}

Перед рассмотрением конкретных механизмов необходимо определить ключевые понятия:

\textbf{Аутентификация} — процесс проверки и подтверждения заявленной идентичности пользователя или сервиса.
Аутентификация отвечает на вопрос <<кто вы?>> и обычно реализуется через проверку учетных данных
(логин и пароль, биометрия, токены, сертификаты).

\textbf{Авторизация} — процесс определения прав доступа аутентифицированного субъекта к конкретным ресурсам системы.
Авторизация отвечает на вопрос <<что вам разрешено делать?>> и выполняется после успешной аутентификации на основе политик доступа,
ролей пользователей или атрибутов запроса.

Пользовательская аутентификация и авторизация являются фундаментальными механизмами обеспечения безопасности в любой распределенной системе.
В микросервисных архитектурах эти процессы приобретают дополнительную сложность,
так как пользовательский запрос может проходить через множество сервисов,
каждый из которых должен принимать решение о предоставлении доступа к ресурсам~\cite{Almeida2022}.

Технически реализация контроля доступа в микросервисных системах опирается на стандартизированные протоколы,
которые обеспечивают безопасную передачу информации об идентичности и правах пользователей между компонентами системы.

\textbf{JSON Web Token (JWT)} — компактный,
URL-безопасный формат для передачи информации о пользователе между клиентом и сервером с защитой от подмены~\cite{RFC7519}.
Структура JWT показана на \firef{fig:jwt-structure}.
Токен состоит из трех частей, разделенных точкой:

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{diagrams/img/jwt-structure}
  \caption{Структура JWT}
  \label{fig:jwt-structure}
\end{figure}

\begin{itemize}
  \item \textbf{Заголовок (Header)} — содержит метаданные о токене, включая тип токена (JWT) и алгоритм подписи (например, HS256, RS256).
  Заголовок кодируется в формате Base64URL\@.

  \item \textbf{Полезная нагрузка (Payload)} — содержит данные о пользователе и служебную информацию.
  Стандартные поля включают идентификатор пользователя (sub), время выпуска токена (iat), время истечения срока действия (exp) и издателя (iss).
  Полезная нагрузка также кодируется в Base64URL\@.

  \item \textbf{Подпись (Signature)} — вычисляется путем подписания закодированных заголовка и полезной нагрузки
  с использованием секретного ключа (HMAC) или приватного ключа (RSA, ECDSA).
  Подпись гарантирует целостность токена и подтверждает, что он не был изменен после выпуска.
\end{itemize}

Основными преимуществами JWT являются компактность и возможность передачи через URL, POST-параметры или HTTP-заголовки.
Токен самодостаточен — он содержит всю необходимую информацию о пользователе,
а также возможность валидации без обращения к базе данных, что критично для масштабируемости микросервисных систем~\cite{Almeida2022}.
Однако JWT имеет и недостатки: сложность отзыва токенов до истечения их срока действия и
потенциальный рост размера токена при добавлении дополнительных атрибутов.

JWT определяет формат представления информации о пользователе, но не регламентирует механизм выдачи токенов и управления доступом к ресурсам.
Для решения этих задач применяется протокол OAuth 2.0.

\textbf{OAuth 2.0} — протокол авторизации, позволяющий приложениям получать ограниченный доступ к ресурсам пользователя без передачи учетных данных~\cite{RFC6749}.
OAuth 2.0 определяет четыре роли: владелец ресурса (resource owner), клиент (client), сервер ресурсов (resource server) и сервер авторизации (authorization server).
Протокол поддерживает различные потоки авторизации (grant types):
\begin{itemize}
  \item \textbf{Authorization Code} — наиболее безопасный поток для веб-приложений.
  \item \textbf{Implicit} — упрощенный поток для одностраничных приложений (устарел).
  \item \textbf{Resource Owner Password Credentials} — для доверенных приложений.
  \item \textbf{Client Credentials} — для межсервисного взаимодействия.
\end{itemize}

OAuth 2.0 эффективно решает задачу авторизации,
однако не предоставляет стандартизированного механизма аутентификации.

\textbf{OpenID Connect (OIDC)} — надстройка над OAuth 2.0, добавляющая функциональность аутентификации~\cite{OpenIDConnect}.
OIDC вводит концепцию ID Token --- JWT-токена, содержащего информацию об аутентифицированном пользователе.
OIDC решает проблему OAuth 2.0, который изначально проектировался только для авторизации, но часто ошибочно использовался и для аутентификации.

Рассмотренные протоколы определяют стандарт, однако их практическая реализация требует специализированной системы.

\textbf{Identity Provider (IdP)} является такой системой,
которая предоставляет услуги аутентификации и управления пользователями.
Применение централизованного IdP в микросервисной архитектуре дает ряд преимуществ~\cite{Almeida2022,Sousa2025}:

\begin{enumerate}
  \item \textbf{Единая точка аутентификации} — пользователи проходят аутентификацию один раз,
  получая доступ ко всем сервисам системы.
  \item \textbf{Централизованное управление политиками} — изменение прав доступа или отключение пользователя происходит
  в одном месте и немедленно распространяется на все сервисы.
  \item \textbf{Федерация} — возможность интеграции с внешними провайдерами (например, Yandex Identity Hub, корпоративный LDAP),
  что упрощает процесс регистрации и входа для пользователей.
  \item \textbf{Разделение ответственности} — разработчики микросервисов могут сосредоточиться на бизнес-логике,
  делегируя вопросы аутентификации специализированному компоненту.
\end{enumerate}

\subsection{Межсервисная аутентификация и авторизация}\label{subsec:1.1.1}

Рассмотренные выше механизмы обеспечивают безопасность взаимодействия конечных пользователей с системой.
Однако в микросервисной архитектуре критически важно также защитить взаимодействие между самими сервисами.

Межсервисное взаимодействие создает дополнительные векторы атак: злоумышленник, получивший доступ к одному скомпрометированному сервису,
может использовать его для несанкционированного доступа к другим компонентам системы~\cite{Almeida2022}.
Традиционный подход, основанный на защите периметра, оказывается неэффективным в условиях распределенных систем~\cite{NIST2023}.

Для решения этой проблемы в современных распределенных системах применяется концепция Zero Trust,
которая предполагает, что сеть по умолчанию является враждебной,
и никакому компоненту системы нельзя доверять без явной проверки~\cite{NIST2023,Arora2024}.
Основными принципами Zero Trust являются:
\begin{itemize}
  \item \textbf{Верификация каждого запроса} — каждый запрос между сервисами
  должен быть аутентифицирован и авторизован, независимо от его источника.
  \item \textbf{Минимальные привилегии} — каждый сервис должен иметь доступ только к тем ресурсам,
  которые необходимы для выполнения его функций.
  \item \textbf{Сегментация сети} — микросервисы должны быть изолированы друг от друга,
  чтобы компрометация одного не приводила к компрометации всей системы.
  \item \textbf{Непрерывный мониторинг} — постоянный анализ поведения сервисов для обнаружения аномалий.
\end{itemize}

Реализация принципов Zero Trust требует выбора конкретных технических механизмов аутентификации и авторизации.
Рассмотрим основные подходы к обеспечению безопасного взаимодействия между микросервисами.
Простейшим вариантом является использование тех же механизмов, что и для пользовательской аутентификации:
передача JWT-токенов в заголовках HTTP-запросов или использование OAuth 2.0 Client Credentials flow~\cite{Zimina2023}.
Однако эти подходы имеют существенные недостатки:
\begin{itemize}
  \item Необходимость встраивания логики аутентификации в каждый микросервис.
  \item Сложность управления секретными ключами для подписи и проверки токенов.
  \item Отсутствие защиты на уровне транспорта — передаваемые данные могут быть перехвачены при атаке типа Man-in-the-Middle.
\end{itemize}

Более надежным подходом является использование \textbf{Transport Layer Security (TLS)} — криптографического протокола,
обеспечивающего защищенную передачу данных по сети~\cite{RFC8446}.
TLS гарантирует:
\begin{itemize}
  \item \textbf{Конфиденциальность} — шифрование данных предотвращает их перехват.
  \item \textbf{Целостность} — механизмы хеширования обеспечивают обнаружение модификации данных.
  \item \textbf{Аутентификацию сервера} — клиент может проверить подлинность сервера через его сертификат.
\end{itemize}

Однако стандартный TLS обеспечивает только одностороннюю аутентификацию (клиент проверяет сервер).
Для межсервисного взаимодействия требуется взаимная аутентификация обеих сторон, что реализуется в \textbf{mutual TLS (mTLS)}~\cite{Almeida2022}.

В mTLS как клиент, так и сервер представляют и проверяют сертификаты, подтверждающие их идентичность.
Процесс установления mTLS-соединения показан на \firef{fig:mtls} и включает следующие этапы:

\begin{enumerate}
  \item Клиент инициирует TLS-handshake, отправляя поддерживаемые криптографические алгоритмы.
  \item Сервер выбирает алгоритмы и отправляет свой сертификат.
  \item Клиент проверяет сертификат сервера, используя доверенный центр сертификации (Certificate Authority, CA).
  \item Сервер запрашивает сертификат клиента.
  \item Клиент отправляет свой сертификат, который проверяется сервером.
  \item Обе стороны генерируют сеансовые ключи для шифрования дальнейшей коммуникации.
\end{enumerate}

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{diagrams/img/mtls}
  \caption{Установление mTLS соединения}
  \label{fig:mtls}
\end{figure}

Преимущества mTLS очевидны: сильная криптографическая аутентификация,
шифрование данных и отсутствие необходимости передавать секреты в заголовках запросов.
Однако реализация mTLS в микросервисной архитектуре сопряжена с операционными сложностями:

\begin{itemize}
  \item Необходимость выпуска и распространения сертификатов для каждого микросервиса.
  \item Управление жизненным циклом сертификатов (ротация, отзыв).
  \item Конфигурирование каждого сервиса для поддержки mTLS\@.
  \item Увеличение сложности отладки и мониторинга.
\end{itemize}

Описанные сложности ручной реализации mTLS привели к появлению специализированных инфраструктурных решений,
автоматизирующих управление сертификатами и политиками безопасности.
Наиболее эффективным подходом является использование Service Mesh.

Service Mesh — это выделенный инфраструктурный слой для управления межсервисной коммуникацией в микросервисных архитектурах~\cite{Koschel2021,Arora2024,Hahn2020}.
Ключевая идея Service Mesh — абстрагирование функций безопасности, мониторинга и управления трафиком от бизнес-логики приложений
через паттерн Sidecar, при котором каждый микросервис дополняется прокси-контейнером,
перехватывающим весь входящий и исходящий сетевой трафик.

Основные компоненты Service Mesh включают:

\begin{itemize}
  \item \textbf{Data Plane} — множество всех sidecar-прокси (например, Envoy), развертываемых вместе с каждым экземпляром микросервиса.
  Data Plane отвечает за фактическую обработку трафика, включая маршрутизацию, балансировку нагрузки, реализацию политик безопасности и сбор метрик.

  \item \textbf{Control Plane} — централизованный компонент, который управляет конфигурацией sidecar-прокси,
  распространяет политики безопасности, собирает телеметрию и предоставляет API\@ для управления сетью.
\end{itemize}

Архитектура Service Mesh и ее взаимодействие с внешними системами аутентификации показана на примере Istio на \firef{fig:istio-full-arch}.
Service Mesh предоставляет следующие возможности для обеспечения безопасности межсервисного взаимодействия~\cite{PlatformV2025}:

\begin{enumerate}
  \item \textbf{Автоматическое mTLS\@} — Service Mesh автоматически выпускает, распространяет и ротирует сертификаты для всех сервисов в сети.
  Разработчикам не нужно модифицировать код приложений для поддержки mTLS\@.

  \item \textbf{Управление идентичностью} — каждому сервису присваивается криптографическая идентичность
  на основе стандарта SPIFFE (Secure Production Identity Framework For Everyone)~\cite{SPIFFE}.
  Идентичность кодируется в сертификате и используется для принятия решений об авторизации.

  \item \textbf{Политики авторизации} — Service Mesh позволяет декларативно описывать правила доступа между сервисами
  на основе их идентичности, атрибутов запроса и других параметров.

  \item \textbf{Интеграция с внешней аутентификацией} — Service Mesh может интегрироваться с системами пользовательской аутентификации (IdP),
  проверяя JWT-токены на уровне сети.
\end{enumerate}

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{diagrams/img/istio-full-arch}
  \caption{Архитектура Service Mesh (на примере Istio)}
  \label{fig:istio-full-arch}
\end{figure}

Control Plane управляет конфигурацией sidecar-прокси в Data Plane,
распространяет сертификаты для mTLS и политики авторизации.
При поступлении пользовательского запроса sidecar-прокси валидирует JWT-токен, полученный от IdP,
и на основе политик авторизации принимает решение о доступе к целевому сервису.
Межсервисное взаимодействие защищено mTLS с автоматической ротацией сертификатов.

Популярными реализациями Service Mesh являются Istio, Linkerd, Consul Connect и Cilium~\cite{Hahn2020}.
Каждая из этих систем имеет свои особенности, но все они следуют общей архитектуре с разделением на data plane и control plane.
Использование Service Mesh значительно упрощает реализацию безопасного межсервисного взаимодействия,
позволяя командам разработки сосредоточиться на бизнес-логике, а не на инфраструктурных аспектах безопасности.

\subsection{Логирование и аудит}\label{subsec:1.1.3}

Рассмотренные механизмы аутентификации и авторизации обеспечивают контроль доступа в реальном времени.
Однако для полноценной системы безопасности необходима также возможность ретроспективного анализа событий,
что достигается через логирование и аудит.

Логирование и аудит являются критически важными компонентами подсистемы безопасности микросервисных систем~\cite{Laigner2024}.
В отличие от монолитных приложений, где все события записываются в единый лог-файл,
в микросервисной архитектуре каждый сервис генерирует собственные логи,
что создает сложности в обеспечении целостного представления о происходящих в системе событиях.

Логирование выполняет несколько ключевых функций с точки зрения информационной безопасности:

\begin{itemize}
  \item \textbf{Обнаружение инцидентов} — анализ логов позволяет выявлять подозрительную активность
  и потенциальные атаки в режиме реального времени.
  \item \textbf{Расследование инцидентов} — детальные логи дают возможность реконструировать
  последовательность событий при анализе инцидентов безопасности.
  \item \textbf{Соответствие требованиям} — многие стандарты и регуляторные требования
  предписывают обязательное ведение аудиторских логов определенных типов событий~\cite{GOST27001,GDPR}.
  \item \textbf{Мониторинг доступа} — логирование событий аутентификации и авторизации
  обеспечивает прослеживаемость действий пользователей и сервисов.
\end{itemize}

В работе А.И. Барабанова и Д.Макрушина~\cite{Barabanov2021} проведен анализ архитектурных паттернов логирования
в микросервисных системах и выявлены следующие подходы и рекомендации.

В логах микросервисной системы должны фиксироваться определенные типы событий безопасности:
\begin{enumerate}
  \item Успешные и неуспешные попытки аутентификации.
  \item Решения об авторизации (разрешение или запрет доступа).
  \item Ошибки приложения и системные события.
  \item Использование критичных функций (изменение настроек, управление пользователями).
  \item Ошибки валидации входных данных.
  \item Изменения состояния сервисов (запуск, остановка, перезапуск).
\end{enumerate}

Также рекомендуемая практика — использование структурированного формата логов (JSON, CSV),
что облегчает последующий анализ и поиск по логам.
Каждое логируемое событие должно включать следующие атрибуты:
\begin{itemize}
  \item Временная метка с точностью до наносекунд (ISO 8601).
  \item Уровень важности события (INFO, WARNING, ERROR).
  \item Идентификатор корреляции (correlation ID) для связывания логов в рамках одного запроса.
  \item Контекст запроса (HTTP-метод, путь, IP-адрес источника, User-Agent).
  \item Идентификатор пользователя или сервиса-инициатора.
  \item Информация о платформе (имя контейнера, namespace в Kubernetes).
\end{itemize}

\textbf{Прямая отправка логов в централизованную систему}.
Наивный подход, при котором каждый микросервис напрямую отправляет логи в центральное хранилище через сетевые запросы (например, через HTTP API\@).
Архитектура данного паттерна показана на \firef{fig:direct-logs-arch}.

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{diagrams/img/direct-logs-arch}
  \caption{Паттерн прямой отправки логов}
  \label{fig:direct-logs-arch}
\end{figure}

В этом подходе микросервисы через встроенные библиотеки логирования
напрямую взаимодействуют с центральным сервисом логирования, который сохраняет логи в хранилище.
Данный паттерн имеет серьезные недостатки:
\begin{itemize}
  \item При недоступности системы логирования микросервис может потерять данные.
  \item Необходимость встраивания логики отправки логов в код каждого сервиса.
  \item Высокая нагрузка на сеть при большом объеме логов.
\end{itemize}

\textbf{Использование агента для сбора логов}.
Более надежный подход, в котором микросервисы записывают логи в локальные файлы (обычно через stdout/stderr),
а специализированный агент периодически считывает эти логи и отправляет их в центральную систему.
Преимущества данного паттерна:
\begin{itemize}
  \item Изоляция микросервиса от системы логирования --- при сбоях логирования работа сервиса не нарушается.
  \item Микросервисы используют стандартный вывод, что упрощает разработку и делает их независимыми от конкретной системы логирования.
  \item Буферизация логов на локальном уровне снижает риск потери данных.
\end{itemize}

Для обеспечения высокой надежности и производительности рекомендуется использовать асинхронную архитектуру с брокером сообщений.
Архитектура данного паттерна представлена на \firef{fig:broker-logs-arch}.

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{diagrams/img/broker-logs-arch}
  \caption{Паттерн асинхронной доставки логов через брокера}
  \label{fig:broker-logs-arch}
\end{figure}

В этом подходе микросервисы записывают логи в локальные файлы внутри контейнеров,
агент логирования собирает логи со всех контейнеров на хосте и публикует их в топики
брокера сообщений с высокой доступностью (то есть брокер размещен в нескольких экземплярах в разных зонах).
Центральный сервис логирования читает сообщения из топиков и сохраняет их в хранилище.
Данная архитектура обеспечивает:
\begin{itemize}
  \item Изоляцию микросервисов от системы логирования — микросервисы продолжают работать даже при недоступности брокера.
  \item Буферизацию на уровне брокера — сообщения не теряются при временных сбоях центральной системы.
  \item Возможность горизонтального масштабирования как брокера, так и системы логирования.
  \item Гарантии доставки сообщений согласно политикам брокера.
\end{itemize}

Подводя итог, такая архитектура позволяет обрабатывать большие объемы логов и защищает от потери данных при временных сбоях компонентов системы.

Помимо технических логов, связанных с работой инфраструктуры и безопасности, важную роль играют продуктовые события~\cite{Alshikh2020}.
Это события, отражающие значимые бизнес-операции (создание заказа, изменение статуса платежа, модификация профиля пользователя).
Для таких событий часто создается отдельный сервис аудита, который:
\begin{itemize}
  \item Принимает события от других микросервисов через асинхронные механизмы.
  \item Обогащает события дополнительным контекстом.
  \item Сохраняет их в специализированном хранилище с длительным сроком хранения.
  \item Предоставляет API\@ для запросов и аналитики.
\end{itemize}

Разделение технических и бизнес-логов позволяет применять разные стратегии хранения и обработки для каждого типа данных.

Помимо архитектурных решений, важным аспектом является управление объемом логов.
В микросервисных системах объем генерируемых данных может достигать терабайтов в сутки,
что требует применения стратегий оптимизации.
Для оптимизации затрат применяются следующие подходы:

\begin{itemize}
  \item \textbf{Иерархическое хранение} — <<горячие>> логи (последних нескольких дней) хранятся в быстрых, но дорогих хранилищах,
  <<холодные>> — переносятся в архивные системы с более низкой стоимостью.
  \item \textbf{Агрегация и сэмплирование} — для логов с низким уровнем важности может применяться выборочное сохранение (например, 1 из 100 записей).
  \item \textbf{Политики retention} — определение сроков хранения для разных категорий логов в соответствии с требованиями бизнеса и регуляторов.
  \item \textbf{Фильтрация чувствительных данных} — автоматическое удаление или маскирование персональных данных,
  паролей и API ключей перед отправкой логов в централизованное хранилище.
\end{itemize}

Правильно спроектированная система логирования и аудита обеспечивает баланс между требованиями безопасности,
производительностью системы и экономическими ограничениями.


\section{Выделение критериев сравнения и подбор инструментальных средств на их основе}\label{sec:1.2}

На основе проведенного анализа существующих подходов к построению подсистем AAA
необходимо выбрать конкретные инструментальные средства для реализации.
Процесс выбора основывается на наборе критериев:
общих для всех категорий инструментов, а также специфичных для каждой категории.
К универсальным критериям относятся:

\begin{itemize}
  \item \textbf{Тип лицензии} — предпочтительны решения с открытым исходным кодом c лицензиями Apache 2.0, MIT, BSD\@.
  Проприетарные решения с ограничениями на бесплатное использование получают низкую оценку.

  \item \textbf{Интеграция с Kubernetes (или Helm Chart)} — разрабатываемая система полностью развертывается в Kubernetes,
  поэтому нативная поддержка этой платформы критически важна для снижения стоимости разработки и эксплуатации.
  Наличие официального Helm Chart значительно упрощает развертывание.

  \item \textbf{Зрелость и стабильность} — наличие стабильных релизов, активное сообщество и применение в крупных компаниях.
  Количество звезд на GitHub служит косвенным индикатором популярности и доверия сообщества.

  \item \textbf{Документация} — качество и полнота официальной документации,
  наличие примеров использования, руководств по интеграции и рекомендаций.

  \item \textbf{Производительность} — инструмент должен потреблять адекватное количество
  вычислительных ресурсов (CPU, память) в контексте выполняемой задачи.

\end{itemize}

Для количественного сравнения альтернатив используется балльная шкала от 0 до 5,
где 0 означает полное отсутствие возможности, 5 — отличную реализацию.
Рассмотрим основные категории инструментальных средств.

\subsection{Identity Provider}\label{subsec:1.2.1}

IdP — это готовая система управления пользовательской идентификацией, аутентификацией и авторизацией.
Для сравнения выбраны следующие решения: Keycloak, Authentik, Zitadel и Ory Hydra.
Критерии сравнения включают поддержку стандартных протоколов,
возможности управления пользователями, интеграцию с Kubernetes и гибкость настройки.

\begin{table}[h!]
  \centering
  \caption{Сравнение Identity Provider решений}\label{tab:idp-comparison}
  \begin{tabular}{p{4cm}ccccc}
    \toprule
    \textbf{Критерий}         & \textbf{Keycloak} & \textbf{Authentik} & \textbf{Zitadel} & \textbf{Ory Hydra} \\
    \midrule
    Лицензия                  & Apache 2.0        & MIT                & Apache 2.0       & Apache 2.0         \\ \midrule
    OAuth 2.0 / OIDC          & 5                 & 5                  & 5                & 5                  \\ \midrule
    Управление пользователями & 5                 & 5                  & 5                & 0                  \\ \midrule
    Helm Chart                & 5                 & 5                  & 5                & 5                  \\ \midrule
    Кастомизация UI           & 4                 & 4                  & 5                & 0                  \\ \midrule
    Федерация IdP             & 5                 & 5                  & 5                & 5                  \\ \midrule
    Детальная авторизация     & 4                 & 3                  & 5                & 0                  \\ \midrule
    Админ-панель              & 5                 & 5                  & 5                & 0                  \\ \midrule
    Мультитенантность         & 5                 & 3                  & 5                & 2                  \\ \midrule
    Документация              & 5                 & 4                  & 5                & 4                  \\ \midrule
    Производительность        & 2                 & 3                  & 4                & 5                  \\ \midrule
    Звезды GitHub (тыс.)      & 31                & 19                 & 9.8              & 16.7               \\
    \bottomrule
  \end{tabular}
\end{table}

Ory Hydra не предоставляет встроенного управления пользователями,
фокусируясь исключительно на федерации (оценка 0 по соответствующим критериям).
Keycloak потребляет больше ресурсов из-за использования JVM (оценка 2),
в то время как решения на Go — Zitadel и Ory Hydra — показывают лучшую эффективность (оценки 4 и 5 соответственно).
Zitadel выделяется продвинутыми возможностями детальный авторизации на основе атрибутов и действий (оценка 5),
превосходя в этом Keycloak (оценка 4).

Zitadel выбран в качестве основного решения благодаря оптимальному балансу
между полнотой функциональности и эффективностью использования ресурсов.
Решение предоставляет все необходимые возможности (управление пользователями, OIDC, мультитенантность, детальная авторизация),
отличную документацию и реализацию на Go, обеспечивающую низкое потребление ресурсов по сравнению решениями на JVM\@.
Наличие официального Helm Chart и активное развитие проекта делают Zitadel идеальным выбором для микросервисной архитектуры.

\subsection{Service Mesh}\label{subsec:1.2.2}

Service Mesh — инфраструктурный слой для обеспечения безопасной межсервисной коммуникации.
Рассматриваются Istio, Linkerd, Cilium и Consul Connect.

\begin{table}[h!]
  \centering
  \caption{Сравнение Service Mesh решений}\label{tab:servicemesh-comparison}
  \begin{tabular}{p{4cm}cccc}
    \toprule
    \textbf{Критерий}    & \textbf{Istio} & \textbf{Linkerd} & \textbf{Cilium} & \textbf{Consul} \\
    \midrule
    Лицензия             & Apache 2.0     & Apache 2.0       & Apache 2.0      & MPL 2.0         \\ \midrule
    Автоматический mTLS  & 5              & 5                & 5               & 5               \\ \midrule
    JWT-валидация        & 5              & 0                & 3               & 3               \\ \midrule
    Политики авторизации & 5              & 3                & 4               & 4               \\ \midrule
    Производительность   & 2              & 5                & 3               & 3               \\ \midrule
    Сложность установки  & 2              & 5                & 3               & 3               \\ \midrule
    Observability        & 5              & 4                & 4               & 4               \\ \midrule
    Traffic management   & 5              & 3                & 4               & 4               \\ \midrule
    Multi-cluster        & 5              & 5                & 5               & 5               \\ \midrule
    Документация         & 5              & 5                & 4               & 4               \\
    \bottomrule
  \end{tabular}
\end{table}

Istio предоставляет наиболее полный набор функций, включая продвинутую валидацию JWT и гибкие политики авторизации (оценка 5),
но требует больше ресурсов и имеет более высокую сложность установки (оценка 2).
Linkerd оптимизирован для простоты и низкого потребления ресурсов (оценка 5), но не поддерживает JWT-валидацию на уровне сети (оценка 0).

Istio выбран благодаря наиболее широкому функционалу безопасности,
интеграции с внешними IdP и богатым возможностям для управления трафиком, несмотря на повышенные требования к ресурсам.

\subsection{Observability Stack}\label{subsec:1.2.3}

Для логирования и мониторинга сравниваются стеки на основе различных технологий:
Victoria Logs+Vector, Loki+Promtail, ELK Stack и Opensearch+Fluentd.

\begin{table}[h!]
  \centering
  \caption{Сравнение систем логирования}\label{tab:logging-comparison}
  \begin{tabular}{p{4cm}cccc}
    \toprule
    \textbf{Критерий}    & \textbf{VictoriaLogs} & \textbf{Loki} & \textbf{ELK} & \textbf{Opensearch} \\
    \midrule
    Лицензия             & Apache 2.0            & AGPL 3.0      & Elastic 2.0  & Apache 2.0          \\ \midrule
    Производительность   & 5                     & 5             & 2            & 3                   \\ \midrule
    Полнотекстовый поиск & 4                     & 3             & 5            & 5                   \\ \midrule
    Индексирование       & 5                     & 5             & 4            & 4                   \\ \midrule
    Helm Chart           & 5                     & 5             & 5            & 5                   \\ \midrule
    Интеграция с Grafana & 5                     & 5             & 4            & 4                   \\ \midrule
    Стоимость хранения   & 5                     & 5             & 2            & 3                   \\ \midrule
    Сложность настройки  & 5                     & 5             & 2            & 3                   \\ \midrule
    Сжатие данных        & 5                     & 4             & 3            & 3                   \\
    \bottomrule
  \end{tabular}
\end{table}

Victoria Logs объединяет преимущества различных подходов:
минимальное потребление ресурсов (оценка 5) благодаря эффективной реализации на Go,
полнотекстовый поиск с поддержкой LogsQL (оценка 5) и исключительное сжатие данных (оценка 5), превосходящее Loki.
Решение распространяется под лицензией Apache 2.0 (оценка 5),
в отличие от ELK с его Elastic License 2.0, ограничивающей коммерческое использование (оценка 3).

Loki также показывает хорошие результаты по ресурсам и стоимости хранения за счет индексирования только меток (оценка 5),
но уступает в возможностях полнотекстового поиска (оценка 3).
ELK предоставляет мощный поиск (оценка 5), однако требует значительных ресурсов (оценка 2) и имеет лицензионные ограничения.

Victoria Logs выбран как оптимальное решение,
обеспечивающее баланс между производительностью, функциональностью и эксплуатационными затратами.
Нативная интеграция с Grafana, совместимость с Vector для сбора логов и возможность горизонтального масштабирования
делают Victoria Logs идеальным выбором для микросервисной архитектуры.
Дополнительным преимуществом является экосистемная совместимость с Victoria Metrics для метрик,
что упрощает операционное управление стеком.

Для сбора и хранения метрик сравниваются решения на основе различных подходов:
Prometheus (эталонная реализация), Victoria Metrics, Thanos (расширение Prometheus) и Mimir.

\begin{table}[h!]
  \centering
  \caption{Сравнение систем мониторинга метрик}\label{tab:metrics-comparison}
  \begin{tabular}{p{4cm}cccc}
    \toprule
    \textbf{Критерий}              & \textbf{Prometheus} & \textbf{VictoriaMetrics} & \textbf{Thanos} & \textbf{Mimir} \\
    \midrule
    Лицензия                       & Apache 2.0          & Apache 2.0               & Apache 2.0      & AGPL 3.0       \\ \midrule
    Совместимость с Prometheus     & 5                   & 5                        & 5               & 5              \\ \midrule
    Производительность             & 3                   & 5                        & 3               & 4              \\ \midrule
    Долгосрочное хранение          & 2                   & 5                        & 5               & 5              \\ \midrule
    Helm Chart                     & 5                   & 5                        & 5               & 5              \\ \midrule
    Интеграция с Grafana           & 5                   & 5                        & 5               & 5              \\ \midrule
    Простота настройки             & 5                   & 5                        & 2               & 3              \\ \midrule
    Горизонтальное масштабирование & 2                   & 5                        & 5               & 5              \\ \midrule
    Сжатие данных                  & 3                   & 5                        & 4               & 4              \\
    \bottomrule
  \end{tabular}
\end{table}

Prometheus является де-факто стандартом для мониторинга в Kubernetes (оценка 5 по совместимости и простоте настройки),
однако имеет ограничения в области долгосрочного хранения (оценка 2) и горизонтального масштабирования (оценка 2).
Решение оптимизировано для краткосрочного хранения метрик с локальным дисковым хранилищем.

Victoria Metrics демонстрирует превосходные показатели по всем ключевым метрикам производительности:
минимальное потребление ресурсов (оценка 5) за счет эффективной реализации на Go,
исключительное сжатие данных (оценка 5), превосходящее Prometheus в 7–10 раз,
высокая скорость выполнения запросов MetricsQL (оценка 5).

Thanos и Mimir решают проблему долгосрочного хранения Prometheus (оценка 5), используя объектные хранилища (например, S3),
однако требуют более сложной настройки (оценки 2 и 3 соответственно) и дополнительных компонентов.

Victoria Metrics выбран как основное решение для сбора и хранения метрик благодаря
оптимальному сочетанию производительности, простоты эксплуатации и функциональности.
Полная совместимость с Prometheus экосистемой, нативная поддержка долгосрочного хранения,
минимальные требования к ресурсам и единая экосистема с Victoria Logs для логирования
делают это решение идеальным для микросервисной архитектуры с ограниченными ресурсами.

\subsection{Язык программирования}\label{subsec:1.2.4}

В рамках исследования планируется разработка специализированного микросервиса аудита для централизованного сбора,
обработки и хранения продуктовых событий.
Выбор языка программирования для реализации микросервиса является важным архитектурным решением,
влияющим на производительность, потребление ресурсов и скорость разработки.

Для сравнения рассматриваются наиболее популярные языки программирования в области разработки микросервисов:
Go, Java, C\#, Python и Rust.

\begin{table}[h!]
  \centering
  \caption{Сравнение языков программирования для микросервисов}\label{tab:languages-comparison}
  \begin{tabular}{p{4.5cm}ccccc}
    \toprule
    \textbf{Критерий}                & \textbf{Go} & \textbf{Java} & \textbf{C\#} & \textbf{Python} & \textbf{Rust} \\
    \midrule
    Производительность               & 5           & 4             & 4            & 2               & 5             \\ \midrule
    Потребление памяти               & 5           & 2             & 3            & 1               & 5             \\ \midrule
    Конкурентность                   & 5           & 4             & 4            & 2               & 5             \\ \midrule
    Размер бинарного файла           & 4           & 2             & 3            & N/A             & 4             \\ \midrule
    Скорость компиляции              & 5           & 3             & 4            & N/A             & 2             \\ \midrule
    Кривая обучения                  & 5           & 3             & 4            & 5               & 2             \\ \midrule
    Экосистема библиотек             & 4           & 5             & 5            & 5               & 3             \\ \midrule
    Kubernetes интеграция            & 5           & 4             & 4            & 3               & 4             \\ \midrule
    Стандартная библиотека           & 5           & 4             & 5            & 4               & 4             \\ \midrule
    Совместимость с выбранным стеком & 5           & 3             & 3            & 3               & 3             \\
    \bottomrule
  \end{tabular}
\end{table}

Go демонстрирует выдающиеся характеристики для разработки микросервисов:
высокая производительность (оценка 5), сопоставимая с Rust и превосходящая Java,
минимальное потребление памяти (оценка 5) благодаря отсутствию виртуальной машины,
встроенная поддержка конкурентности (оценка 5).
Компактные статические бинарные файлы (оценка 4) упрощают контейнеризацию и развертывание.

Java обладает зрелой экосистемой (оценка 5), однако требует значительных ресурсов памяти из-за JVM (оценка 2)
и генерирует большие образы контейнеров (оценка 2), что критично для микросервисной архитектуры.

C\# с платформой .NET представляет собой сбалансированное решение:
хорошая производительность (оценка 4), приближающаяся к Go и Java благодаря JIT-компиляции и возможности AOT,
развитая поддержка асинхронного программирования через async/await (оценка 4).
Экосистема NuGet и стандартная библиотека получают высшие оценки (оценка 5).
Однако потребление памяти остается высоким из-за .NET runtime (оценка 3),
а размер образов контейнеров больше по сравнению с Go (оценка 3).
Интеграция с Kubernetes возможна, но не столь естественна, как в случае Go (оценка 3).

Python отличается простотой синтаксиса (оценка 5 по кривой обучения) и богатой экосистемой,
но уступает в производительности (оценка 2)
и не имеет полноценной поддержки параллелизма из-за Global Interpreter Lock (оценка 2).

Rust обеспечивает максимальную производительность и безопасность памяти (оценка 5),
однако имеет крутую кривую обучения (оценка 2) и менее зрелую экосистему для микросервисов (оценка 3).

Критически важным фактором является совместимость с выбранным технологическим стеком:
Zitadel, Victoria Metrics и Victoria Logs реализованы на Go (оценка 5).
Использование единого языка программирования для всей AAA-подсистемы упрощает интеграцию,
позволяет переиспользовать библиотеки и обеспечивает единообразие архитектурных решений.

Go выбран в качестве языка программирования для реализации микросервиса аудита благодаря
оптимальному сочетанию производительности, эффективности использования ресурсов и простоты разработки.


\section{Формулирование задачи и гипотезы ее решения}\label{sec:1.3}

На основе проведенного анализа существующих подходов и инструментальных средств
для построения подсистем AAA в микросервисных архитектурах сформулируем цель, задачи и гипотезы исследования.

\subsection{Цель исследования}\label{subsec:1.3.1}

Целью данного исследования является разработка и реализация компонентов подсистемы аутентификации,
авторизации и аудита для распределенной микросервисной Continuous Delivery платформы,
обеспечивающей безопасное взаимодействие пользователей и сервисов.

\subsection{Задачи исследования}\label{subsec:1.3.2}

Для достижения поставленной цели необходимо решить следующие задачи:

\begin{enumerate}
  \item \textbf{Изучить современные подходы и механизмы обеспечения безопасности в распределенных микросервисных системах.}

  Микросервисная архитектура создает существенные трудности в области безопасности, связанные с распределенностью системы и множественностью точек взаимодействия.
  Требуется систематизировать знания о существующих подходах к решению задач безопасности в подобных системах.

  \textit{Гипотеза:} Комбинация Service Mesh для межсервисной коммуникации и IdP для пользовательского доступа
  в связке с OIDC и OAuth 2.0 позволит создать эффективную основу для AAA-подсистемы.

  \item \textbf{Спроектировать архитектуру AAA-подсистемы.}

  Проектирование архитектуры является критически важным этапом, определяющим успех реализации.
  Необходимо спроектировать систему, которая естественно интегрируется в существующую инфраструктуру платформы,
  обеспечивает требуемый уровень безопасности и сохраняет возможность расширения в будущем.

  \textit{Гипотеза:} Модульная архитектура AAA-подсистемы с разделением компонентов пользовательской и межсервисной аутентификации,
  централизованным сервисом авторизации и единой точкой сбора аудита обеспечит масштабируемость,
  поддерживаемость и возможность независимого развития компонентов.

  \item \textbf{Реализовать компоненты пользовательской аутентификации и авторизации.}

  Основы безопасности системы — пользовательская аутентификация и авторизация.
  Они обеспечивают контроль доступа конечных пользователей к ресурсам платформы.
  Реализация должна использовать современные протоколы и предоставлять инструментарий для использования в других микросервисах платформы.

  \textit{Гипотеза:} Использование готового Identity Provider с поддержкой OIDC и управлением доступа
  на основе прав и ролей позволит реализовать безопасную и удобную аутентификацию и авторизацию пользователей.

  \item \textbf{Реализовать компоненты межсервисной аутентификации и авторизации.}

  В микросервисной архитектуре необходимо обеспечивать безопасное взаимодействие между сервисами.
  Это позволит предотвратить несанкционированный доступ к внутренним API\@ и защитить передаваемые данные.

  \textit{Гипотеза:} Использование Service Mesh технологии позволит с минимальными усилиями реализовать
  безопасный и проверенный способ межсервисного взаимодействия на основе mTLS\@.

  \item \textbf{Реализовать компоненты аудита и мониторинга.}

  Аудит и мониторинг позволяют автоматически обнаруживать инциденты,
  способствуют расследованиям нарушений и прохождению проверок у регуляторов.
  Также эти компоненты отображают происходящие события в системе,
  что полезно в случае неполадок или неправильного использования платформы.

  \textit{Гипотеза:} Реализация централизованной системы аудита на основе агентов-сборщиков логов,
  публикующих события в брокер сообщений с последующей доставкой в систему индексирования и аналитики,
  обеспечит надежный сбор, хранение и анализ событий безопасности при сохранении производительности системы.

  \item \textbf{Провести апробацию разработанной AAA-подсистемы.}

  Апробация необходима для проверки корректности реализации, соответствия требованиям и оценки эффективности решения.
  Апробация включает развертывание подсистемы в Kubernetes кластере,
  проведение функционального тестирования и нагрузочного тестирования.

  \textit{Гипотеза:} Разработанная AAA-подсистема будет соответствовать требованиям безопасности,
  обеспечивать приемлемую производительность и успешно интегрироваться с архитектурой Continuous Delivery платформы.
  Ожидаемые показатели: задержка аутентификации < 100 мс для 95-го процентиля, пропускная способность > 1000 запросов/сек.
\end{enumerate}

Решение сформулированных задач позволит создать комплексную подсистему AAA,
обеспечивающую высокий уровень безопасности при сохранении приемлемой производительности
и удобства разработки для команд, работающих с платформой.


\section{Выводы по главе \thechapter}\label{sec:1.4}

В данной главе проведен анализ подходов к построению подсистем аутентификации, авторизации и аудита в микросервисных архитектурах.
Выполненный обзор литературы и существующих решений позволил выявить ключевые проблемы обеспечения безопасности в распределенных системах и определить эффективные подходы к их решению.

Основные результаты данной части исследования:

\begin{enumerate}
  \item Исследованы стандартизированные протоколы аутентификации и авторизации,
  и обоснована необходимость применения централизованных Identity Provider для обеспечения
  единой точки аутентификации и упрощения управления пользователями в распределенной системе.

  \item Рассмотрены подходы к обеспечению безопасной межсервисной коммуникации.
  Показано, что концепция Zero Trust и использование mTLS являются основой для защиты взаимодействия между микросервисами.
  Установлено, что Service Mesh технологии значительно упрощают реализацию mTLS,
  автоматизируя управление сертификатами и предоставляя декларативные механизмы для определения политик безопасности.

  \item Проанализированы архитектурные паттерны сбора и обработки логов в микросервисных системах.
  Выявлено, что паттерн с агентом логирования и асинхронной доставкой через брокер сообщений обеспечивает
  оптимальный баланс между надежностью, производительностью и изоляцией компонентов.

  \item На основе выделенных критериев проведено сравнение альтернативных инструментальных средств.
  Для реализации подсистемы AAA выбраны: Zitadel (Identity Provider), Istio (Service Mesh),
  Victoria Logs+Vector+Grafana (система логирования), Victoria Metrics (система метрик) и Go (язык программирования).

  \item Сформулированы цель, задачи и гипотезы исследования.
  Определено, что целью является разработка компонентов подсистемы AAA для микросервисной Continuous Delivery платформы.
  Выделены шесть основных задач, для каждой из которых предложены проверяемые гипотезы решения.
\end{enumerate}

% Since it's NRW report – comment this for now
%Результаты анализа создают теоретическую и методологическую основу для проектирования
%и реализации подсистемы AAA, которые будут представлены в последующих главах работы.
