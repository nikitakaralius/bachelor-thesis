\chapter{Анализ подходов к построению подсистем AAA в микросервисных архитектурах}\label{ch:1}

Микросервисная архитектура стала доминирующим подходом к построению современных распределенных систем,
обеспечивая высокую степень масштабируемости, отказоустойчивости и гибкости разработки~\cite{Stojanov2024}.
В отличие от монолитных приложений, где все компоненты тесно связаны и развертываются как единое целое,
микросервисы представляют собой набор небольших независимых сервисов,
каждый из которых выполняет определенную бизнес-функцию и может разрабатываться,
развертываться и масштабироваться независимо~\cite{Glumov2024}.

Однако такая распределенность системы создает существенные вызовы в области информационной безопасности~\cite{Almeida2022}.
Каждый микросервис становится потенциальной точкой входа для злоумышленника,
увеличивая поверхность атаки по сравнению с монолитными системами~\cite{Zimina2023}.
Если в монолите необходимо защитить одну точку входа и одну кодовую базу,
то в микросервисной архитектуре требуется индивидуальное внимание к безопасности каждого сервиса,
что значительно усложняет процесс разработки и поддержки~\cite{Barabanov2021}.
При этом микросервисы взаимодействуют друг с другом по сети,
что требует реализации безопасной межсервисной коммуникации и правильного управления доверием между компонентами системы~\cite{NIST2023}.

Целью данной главы является систематический анализ существующих подходов и решений для построения подсистем AAA в микросервисных архитектурах.
В параграфе~\ref{sec:1.1} рассматриваются основные решения для пользовательской и межсервисной аутентификации, а также подходы к логированию и аудиту.
Параграф~\ref{sec:1.2} посвящен выделению критериев сравнения и подбору инструментальных средств на их основе.
В параграфе~\ref{sec:1.3} формулируется постановка задачи и гипотезы исследования.
Завершает главу параграф~\ref{sec:1.4} с выводами по проведенному анализу.


\section{Обзор имеющихся решений и исследований}\label{sec:1.1}

\subsection{Пользовательская аутентификация и авторизация}\label{subsec:1.1.2}
Пользовательская аутентификация и авторизация являются фундаментальными механизмами обеспечения безопасности в любой распределенной системе~\cite{Glumov2024}.
В микросервисных архитектурах эти процессы приобретают дополнительную сложность,
так как пользовательский запрос может проходить через множество сервисов,
каждый из которых должен принимать решение о предоставлении доступа к ресурсам~\cite{Zimina2023}.

Современные системы используют различные модели контроля доступа,
выбор которых зависит от требований к безопасности и специфики предметной области~\cite{Stojanov2024}:
\begin{enumerate}
  \item \textbf{Дискреционный контроль доступа} (Discretionary Access Control, DAC) — модель,
  в которой владелец ресурса самостоятельно определяет права доступа к нему.
  Данная модель отличается простотой реализации, но имеет существенный недостаток:
  сложность централизованного управления политиками безопасности~\cite{NIST2023}.

  \item \textbf{Мандатный контроль доступа} (Mandatory Access Control, MAC) — модель,
  при которой права доступа определяются системой на основе уровней конфиденциальности субъектов и объектов.
  \item MAC обеспечивает высокий уровень безопасности и часто применяется в государственных и военных системах,
  однако отличается низкой гибкостью~\cite{NIST2023}.

  \item \textbf{Ролевой контроль доступа} (Role-Based Access Control, RBAC) — одна из наиболее распространенных моделей,
  в которой права доступа назначаются ролям, а пользователи получают доступ через членство в этих ролях~\cite{Glumov2024}.
  RBAC хорошо подходит для организаций с устоявшейся структурой и четким разделением обязанностей.

  \item \textbf{Атрибутный контроль доступа} (Attribute-Based Access Control, ABAC) — наиболее гибкая модель,
  в которой решения о доступе принимаются на основе атрибутов субъекта, объекта, действия и окружения~\cite{NIST2023}.
  ABAC позволяет реализовывать сложные политики доступа, учитывающие контекст запроса, что особенно актуально для микросервисных архитектур.
\end{enumerate}

В современных микросервисных системах часто применяется комбинированный подход,
сочетающий RBAC для базового управления доступом и ABAC для более тонкой настройки политик~\cite{Zimina2023}.

Для реализации механизмов аутентификации и авторизации в распределенных системах используются стандартизированные протоколы~\cite{Almeida2022}:

% TODO: JWT structure image
\textbf{JSON Web Token (JWT)} — компактный, URL-безопасный формат для представления утверждений между двумя сторонами~\cite{Glumov2024}.
JWT состоит из трех частей: заголовка (header), полезной нагрузки (payload) и подписи (signature).
Токены могут быть подписаны с использованием секретного ключа (алгоритм HMAC) или пары ключей (RSA, ECDSA).
Основными преимуществами JWT являются:
\begin{itemize}
  \item Компактность и возможность передачи через URL, POST-параметры или HTTP-заголовки;
  \item Самодостаточность — токен содержит всю необходимую информацию о пользователе;
  \item возможность валидации без обращения к базе данных.
\end{itemize}

Однако JWT имеет и недостатки: сложность отзыва токенов до истечения их срока действия и
потенциальный рост размера токена при добавлении дополнительных атрибутов~\cite{Zimina2023}.

% TODO: rfc ref
\textbf{OAuth 2.0} — протокол авторизации, позволяющий приложениям получать ограниченный доступ к ресурсам пользователя без передачи учетных данных~\cite{Stojanov2024}.
OAuth 2.0 определяет четыре роли: владелец ресурса (resource owner), клиент (client), сервер ресурсов (resource server) и сервер авторизации (authorization server).
Протокол поддерживает различные потоки авторизации (grant types):
\begin{itemize}
  \item Authorization Code — наиболее безопасный поток для веб-приложений;
  \item Implicit — упрощенный поток для одностраничных приложений (устарел);
  \item Resource Owner Password Credentials — для доверенных приложений;
  \item Client Credentials — для межсервисного взаимодействия.
\end{itemize}

\textbf{OpenID Connect (OIDC)} — надстройка над OAuth 2.0, добавляющая функциональность аутентификации~\cite{Glumov2024}.
OIDC вводит концепцию ID Token --- JWT-токена, содержащего информацию об аутентифицированном пользователе.
Протокол также определяет стандартную конечную точку UserInfo для получения дополнительных данных о пользователе.
OIDC решает проблему OAuth 2.0, который изначально проектировался только для авторизации, но часто ошибочно использовался и для аутентификации~\cite{Almeida2022}.

\textbf{Identity Provider (IdP)}\label{sec:idp} — это специализированная система, предоставляющая услуги аутентификации и управления пользовательскими идентичностями~\cite{Zimina2023}.
Применение централизованного IdP в микросервисной архитектуре дает ряд преимуществ:

\begin{enumerate}
  \item \textbf{Единая точка аутентификации} — пользователи проходят аутентификацию один раз,
  получая доступ ко всем сервисам системы (Single Sign-On, SSO)~\cite{Glumov2024}.
  \item \textbf{Централизованное управление политиками} — изменение прав доступа или отключение пользователя происходит
  в одном месте и немедленно распространяется на все сервисы~\cite{Barabanov2021}.
  \item \textbf{Федерация идентичности} — возможность интеграции с внешними провайдерами (например, Google, GitHub, корпоративный LDAP),
  что упрощает процесс регистрации и входа для пользователей~\cite{Stojanov2024}.
  \item \textbf{Разделение ответственности} — разработчики микросервисов могут сосредоточиться на бизнес-логике,
  делегируя вопросы аутентификации специализированному компоненту~\cite{Almeida2022}.
\end{enumerate}

\subsection{Межсервисная аутентификация и авторизация}\label{subsec:1.1.1}

В микросервисной архитектуре сервисы постоянно взаимодействуют друг с другом по сети для выполнения бизнес-операций.
Такое взаимодействие создает дополнительные векторы атак: злоумышленник, получивший доступ к одному скомпрометированному сервису,
может использовать его для несанкционированного доступа к другим компонентам системы~\cite{Stojanov2024}.
Традиционный подход, основанный на защите периметра, оказывается неэффективным в условиях распределенных систем~\cite{NIST2023}.

% TODO: Все очень плохо с цитированием. Просто на рандом натыкано.
Концепция Zero Trust предполагает, что сеть по умолчанию является враждебной,
и никакому компоненту системы нельзя доверять без явной проверки~\cite{Almeida2022}.
Основные принципы Zero Trust включают:
\begin{itemize}
  \item \textbf{Верификация каждого запроса} — каждый запрос между сервисами
  должен быть аутентифицирован и авторизован, независимо от его источника~\cite{NIST2023}.
  \item \textbf{Минимальные привилегии} — каждый сервис должен иметь доступ только к тем ресурсам,
  которые необходимы для выполнения его функций~\cite{Stojanov2024}.
  \item \textbf{Сегментация сети} — микросервисы должны быть изолированы друг от друга,
  чтобы компрометация одного не приводила к компрометации всей системы~\cite{Zimina2023}.
  \item \textbf{Непрерывный мониторинг} — постоянный анализ поведения сервисов для обнаружения аномалий~\cite{Barabanov2021}.
\end{itemize}

Для обеспечения безопасного взаимодействия между микросервисами могут применяться различные подходы.
Простейшим вариантом является использование тех же механизмов, что и для пользовательской аутентификации:
передача JWT-токенов в заголовках HTTP-запросов или использование OAuth 2.0 Client Credentials flow~\cite{Glumov2024}.
Однако эти подходы имеют существенные недостатки:
\begin{itemize}
  \item Необходимость встраивания логики аутентификации в каждый микросервис;
  \item Сложность управления секретными ключами для подписи и проверки токенов;
  \item Отсутствие защиты на уровне транспорта — передаваемые данные могут быть перехвачены при атаке типа Man-in-the-Middle~\cite{Zimina2023}.
\end{itemize}

% TODO: TLS rfc
Более надежным подходом является использование \textbf{Transport Layer Security (TLS)} — криптографического протокола,
обеспечивающего защищенную передачу данных по сети~\cite{Stojanov2024}.
TLS гарантирует:
\begin{itemize}
  \item \textbf{Конфиденциальность} — шифрование данных предотвращает их перехват;
  \item \textbf{Целостность} — механизмы хеширования обеспечивают обнаружение модификации данных;
  \item \textbf{Аутентификацию сервера} — клиент может проверить подлинность сервера через его сертификат.
\end{itemize}

Однако стандартный TLS обеспечивает только одностороннюю аутентификацию (клиент проверяет сервер).
Для межсервисного взаимодействия требуется взаимная аутентификация обеих сторон, что реализуется в \textbf{mutual TLS (mTLS)}~\cite{Almeida2022}.

В mTLS как клиент, так и сервер представляют и проверяют сертификаты, подтверждающие их идентичность~\cite{NIST2023}.
Процесс установления mTLS-соединения включает следующие этапы:

% TODO: Диаграмма уже добавлена. Надо сослаться на нее в тексте и списком ниже словесно описать, что происходит.
\begin{enumerate}
  \item Клиент инициирует TLS-handshake, отправляя поддерживаемые криптографические алгоритмы;
  \item Сервер выбирает алгоритмы и отправляет свой сертификат;
  \item Клиент проверяет сертификат сервера, используя доверенный центр сертификации (Certificate Authority, CA);
  \item Сервер запрашивает сертификат клиента;
  \item Клиент отправляет свой сертификат, который проверяется сервером;
  \item Обе стороны генерируют сеансовые ключи для шифрования дальнейшей коммуникации~\cite{Stojanov2024}.
\end{enumerate}

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{diagrams/img/mtls}
  \caption{Установление mTLS соединения}
  \label{fig:mtls}
\end{figure}

Преимущества mTLS очевидны: сильная криптографическая аутентификация,
шифрование данных в транзите и отсутствие необходимости передавать секреты в заголовках запросов~\cite{Zimina2023}.
Однако реализация mTLS в микросервисной архитектуре сопряжена с операционными сложностями:

\begin{itemize}
  \item Необходимость выпуска и распространения сертификатов для каждого микросервиса;
  \item Управление жизненным циклом сертификатов (ротация, отзыв);
  \item Конфигурирование каждого сервиса для поддержки mTLS\@;
  \item Увеличение сложности отладки и мониторинга~\cite{Barabanov2021}.
\end{itemize}

Service Mesh — это выделенный инфраструктурный слой для управления межсервисной коммуникацией в микросервисных архитектурах~\cite{Koschel2021}.
Service Mesh абстрагирует функции безопасности, мониторинга и управления трафиком от бизнес-логики приложений, реализуя паттерн Sidecar.
При использовании этого паттерна каждый микросервис дополняется прокси-контейнером,
который перехватывает весь входящий и исходящий сетевой трафик~\cite{Almeida2022}.

Основные компоненты Service Mesh включают:

\begin{itemize}
  \item \textbf{Data Plane} — множество sidecar-прокси (например, Envoy), развертываемых вместе с каждым экземпляром микросервиса.
  Data Plane отвечает за фактическую обработку трафика, включая маршрутизацию, балансировку нагрузки, реализацию политик безопасности и сбор метрик.

  \item \textbf{Control Plane} — централизованный компонент, который управляет конфигурацией sidecar-прокси,
  распространяет политики безопасности, собирает телеметрию и предоставляет API\@ для управления сетью.
\end{itemize}

Service Mesh предоставляет следующие возможности для обеспечения безопасности межсервисного взаимодействия~\cite{Koschel2021}:

\begin{enumerate}
  \item \textbf{Автоматическое mTLS\@} — Service Mesh автоматически выпускает, распространяет и ротирует сертификаты для всех сервисов в mesh.
  Разработчикам не нужно модифицировать код приложений для поддержки mTLS\@~\cite{NIST2023}.

  \item \textbf{Управление идентичностью} — каждому сервису присваивается криптографическая идентичность
  на основе стандарта SPIFFE (Secure Production Identity Framework For Everyone).
  Идентичность кодируется в сертификате и используется для принятия решений об авторизации.

  \item \textbf{Политики авторизации} — Service Mesh позволяет декларативно описывать правила доступа между сервисами
  на основе их идентичности, атрибутов запроса и других параметров.

  \item \textbf{Интеграция с внешней аутентификацией} — Service Mesh может интегрироваться с системами пользовательской аутентификации (IdP),
  проверяя JWT-токены на уровне mesh и преобразуя пользовательскую идентичность в атрибуты для принятия решений об авторизации.
\end{enumerate}

Популярными реализациями Service Mesh являются Istio, Linkerd, Consul Connect и Cilium.
Каждая из этих систем имеет свои особенности, но все они следуют общей архитектуре с разделением на data plane и control plane.
Использование Service Mesh значительно упрощает реализацию безопасного межсервисного взаимодействия,
позволяя командам разработки сосредоточиться на бизнес-логике, а не на инфраструктурных аспектах безопасности~\cite{Barabanov2021}.

\subsection{Логирование и аудит}\label{subsec:1.1.3}
% Тоже начать с того, какую проблему решаем (опираться на источники как и ранее).
% Кратко введение в мониторинг. Почему мы его относим к безопасности системы.
% Рассказать про различные паттерны сбора логов (где-то было про это).
% Круто зайдут диаграммы. Особенно если рассказывать про HA кластер. Но пока не добавляем.
% Где-то было про запись в std output (подкрепить источник).
% Хотелось бы источник про продуктовые события, что это отдельный сервис, как с ним работать.
% Уделить внимание ресурсам, времени жизни – логов много, это все выливается в деньги.

Логирование и аудит являются критически важными компонентами подсистемы безопасности микросервисных систем.
В отличие от монолитных приложений, где все события записываются в единый лог-файл,
в микросервисной архитектуре каждый сервис генерирует собственные логи,
что создает сложности в обеспечении целостного представления о происходящих в системе событиях.

Логирование выполняет несколько ключевых функций с точки зрения информационной безопасности~\cite{Barabanov2021}:

\begin{itemize}
  \item \textbf{Обнаружение инцидентов} — анализ логов позволяет выявлять подозрительную активность
  и потенциальные атаки в режиме реального времени.
  \item \textbf{Расследование инцидентов} — детальные логи дают возможность реконструировать
  последовательность событий при анализе инцидентов безопасности.
  % TODO: сюда ГОСТ нужен
  \item \textbf{Соответствие требованиям} — многие стандарты и регуляторные требования (PCI DSS, GDPR, ISO 27001)
  предписывают обязательное ведение аудиторских логов определенных типов событий.
  \item \textbf{Мониторинг доступа} — логирование событий аутентификации и авторизации
  обеспечивает прослеживаемость действий пользователей и сервисов.
\end{itemize}

Согласно исследованию~\cite{Barabanov2021}, в логах микросервисной системы должны фиксироваться следующие типы событий безопасности:
\begin{enumerate}
  \item Успешные и неуспешные попытки аутентификации;
  \item Решения об авторизации (разрешение или запрет доступа);
  \item Ошибки приложения и системные события;
  \item Использование критичных функций (изменение настроек, управление пользователями);
  \item Ошибки валидации входных данных;
  \item Изменения состояния сервисов (запуск, остановка, перезапуск).
\end{enumerate}

В работе~\cite{Barabanov2021} проведен систематический анализ архитектурных паттернов логирования
в микросервисных системах и выявлены следующие подходы:

% TODO: тут везде диаграммы
\textbf{Прямая отправка логов в централизованную систему}.
Наивный подход, при котором каждый микросервис напрямую отправляет логи в центральное хранилище через сетевые запросы (например, через HTTP API\@).
Данный паттерн имеет серьезные недостатки:
\begin{itemize}
  \item При недоступности системы логирования микросервис может потерять данные;
  \item Необходимость встраивания логики отправки логов в код каждого сервиса;
  \item Высокая нагрузка на сеть при большом объеме логов.
\end{itemize}

\textbf{Использование агента для сбора логов}.
Более надежный подход, в котором микросервисы записывают логи в локальные файлы (обычно через stdout/stderr),
а специализированный агент периодически считывает эти логи и отправляет их в центральную систему.
Преимущества данного паттерна:
\begin{itemize}
  \item Изоляция микросервиса от системы логирования --- при сбоях логирования работа сервиса не нарушается;
  \item Микросервисы используют стандартный вывод, что упрощает разработку и делает их независимыми от конкретной системы логирования;
  \item Буферизация логов на локальном уровне снижает риск потери данных.
\end{itemize}

Рекомендуемая практика --- использование структурированного формата логов (JSON, CSV),
что облегчает последующий анализ и поиск по логам.
Каждое логируемое событие должно включать следующие атрибуты:
\begin{itemize}
  \item Временная метка с точностью до наносекунд (ISO 8601);
  \item Уровень важности события (INFO, WARNING, ERROR);
  \item Идентификатор корреляции (correlation ID) для связывания логов в рамках одного запроса;
  \item Контекст запроса (HTTP-метод, путь, IP-адрес источника, User-Agent);
  \item Идентификатор пользователя или сервиса-инициатора;
  \item Информация о платформе (имя контейнера, namespace в Kubernetes).
\end{itemize}

\textbf{Асинхронная доставка через message broker}.
Для обеспечения высокой надежности и производительности рекомендуется использовать асинхронную архитектуру с брокером сообщений.
В этом подходе:
\begin{enumerate}
  \item Агент логирования публикует логи в топики брокера сообщений;
  \item Центральная система логирования подписывается на топики и обрабатывает сообщения;
  \item Брокер обеспечивает гарантии доставки и возможность горизонтального масштабирования.
\end{enumerate}

Такая архитектура позволяет обрабатывать большие объемы логов и защищает от потери данных при временных сбоях компонентов системы.

Помимо технических логов, связанных с работой инфраструктуры и безопасности, важную роль играют продуктовые события~\cite{Glumov2024}.
Это события, отражающие значимые бизнес-операции (создание заказа, изменение статуса платежа, модификация профиля пользователя).
Для таких событий часто создается отдельный сервис аудита, который:
\begin{itemize}
  \item Принимает события от других микросервисов через асинхронные механизмы;
  \item Обогащает события дополнительным контекстом;
  \item Сохраняет их в специализированном хранилище с длительным сроком жизни;
  \item Предоставляет API\@ для запросов и аналитики.
\end{itemize}

Разделение технических и бизнес-логов позволяет применять разные стратегии хранения и обработки для каждого типа данных.

Одной из существенных проблем логирования в микросервисных системах является большой объем генерируемых данных.
Для оптимизации затрат применяются следующие подходы:

\begin{itemize}
  \item \textbf{Иерархическое хранение} — <<горячие>> логи (последних нескольких дней) хранятся в быстрых, но дорогих хранилищах,
  <<холодные>> — переносятся в архивные системы с более низкой стоимостью.
  \item \textbf{Агрегация и сэмплирование} — для логов с низким уровнем важности может применяться выборочное сохранение (например, 1 из 100 записей).
  \item \textbf{Политики retention} — определение сроков хранения для разных категорий логов в соответствии с требованиями бизнеса и регуляторов.
  \item \textbf{Фильтрация чувствительных данных} — автоматическое удаление или маскирование персональных данных,
  паролей и API ключей перед отправкой логов в централизованное хранилище.
\end{itemize}

Правильно спроектированная система логирования и аудита обеспечивает баланс между требованиями безопасности,
производительностью системы и экономическими ограничениями.


\section{Выделение критериев сравнения и подбор инструментальных средств на их основе}\label{sec:1.2}

На основе проведенного анализа существующих подходов к построению подсистем AAA
необходимо выбрать конкретные инструментальные средства для реализации.
Процесс выбора основывается на наборе критериев:
общих для всех категорий инструментов, а также специфичных для каждой категории.
К универсальным критериям относятся:

\begin{itemize}
  \item \textbf{Тип лицензии} — предпочтительны решения с открытым исходным кодом c лицензиями Apache 2.0, MIT, BSD,
  обеспечивающими прозрачность, возможность аудита безопасности и отсутствие коммерческих ограничений на использование.
  Проприетарные решения с ограничениями на бесплатное использование получают низкую оценку;

  \item \textbf{Интеграция с Kubernetes (или Helm Chart)} — разрабатываемая система полностью развертывается в Kubernetes,
  поэтому нативная поддержка этой платформы критически важна для снижения стоимости разработки и эксплуатации.
  Наличие официального Helm Chart значительно упрощает развертывание;

  \item \textbf{Зрелость и стабильность} — наличие стабильных релизов, активное сообщество и применение в крупных компаниях.
  Количество звезд на GitHub служит косвенным индикатором популярности и доверия сообщества;

  \item \textbf{Документация} — качество и полнота официальной документации,
  наличие примеров использования, руководств по интеграции и рекомендаций;

  \item \textbf{Производительность} — инструмент должен потреблять адекватное количество
  вычислительных ресурсов (CPU, память) в контексте выполняемой задачи,
  что критично для микросервисной архитектуры с множеством компонентов;

\end{itemize}

Для количественного сравнения альтернатив используется балльная шкала от 0 до 5,
где 0 означает полное отсутствие возможности, 5 — отличную реализацию.
Рассмотрим основные категории инструментальных средств.

\subsection{Identity Provider}\label{subsec:1.2.1}

IdP — это готовая система управления пользовательской идентификацией, аутентификацией и авторизацией.
Для сравнения выбраны следующие решения: Keycloak, Authentik, Zitadel и Ory Hydra.
Критерии сравнения включают поддержку стандартных протоколов,
возможности управления пользователями, интеграцию с Kubernetes и гибкость настройки.

\begin{table}[h!]
  \centering
  \caption{Сравнение Identity Provider решений}\label{tab:idp-comparison}
  \begin{tabular}{p{4cm}ccccc}
    \toprule
    \textbf{Критерий}         & \textbf{Keycloak} & \textbf{Authentik} & \textbf{Zitadel} & \textbf{Ory Hydra} \\
    \midrule
    Лицензия                  & Apache 2.0)       & MIT                & Apache 2.0       & Apache 2.0         \\ \midrule
    OAuth 2.0 / OIDC          & 5                 & 5                  & 5                & 5                  \\ \midrule
    Управление пользователями & 5                 & 5                  & 5                & 0                  \\ \midrule
    Helm Chart                & 5                 & 5                  & 5                & 5                  \\ \midrule
    Кастомизация UI           & 4                 & 4                  & 5                & 0                  \\ \midrule
    Федерация IdP             & 5                 & 5                  & 5                & 5                  \\ \midrule
    Детальная авторизация     & 4                 & 3                  & 5                & 0                  \\ \midrule
    Админ-панель              & 5                 & 5                  & 5                & 0                  \\ \midrule
    Мультитенантность         & 5                 & 3                  & 5                & 2                  \\ \midrule
    Документация              & 5                 & 4                  & 5                & 4                  \\ \midrule
    Производительность        & 2                 & 3                  & 4                & 5                  \\ \midrule
    Звезды GitHub (тыс.)      & 31                & 19                 & 9.8              & 16.7               \\
    \bottomrule
  \end{tabular}
\end{table}

Ory Hydra не предоставляет встроенного управления пользователями,
фокусируясь исключительно на федерации (оценка 0 по соответствующим критериям).
Keycloak потребляет больше ресурсов из-за использования JVM (оценка 2),
в то время как решения на Go — Zitadel и Ory Hydra — показывают лучшую эффективность (оценки 4 и 5 соответственно).
Zitadel выделяется продвинутыми возможностями детальный авторизации на основе атрибутов и действий (оценка 5),
превосходя в этом Keycloak (оценка 4).

Zitadel выбран в качестве основного решения благодаря оптимальному балансу
между полнотой функциональности и эффективностью использования ресурсов.
Решение предоставляет все необходимые возможности (управление пользователями, OIDC, мультитенантность, детальная авторизация),
отличную документацию и реализацию на Go, обеспечивающую низкое потребление ресурсов по сравнению решениями на JVM\@.
Наличие официального Helm Chart и активное развитие проекта делают Zitadel идеальным выбором для микросервисной архитектуры.

\subsection{Service Mesh}\label{subsec:1.2.2}

Service Mesh — инфраструктурный слой для обеспечения безопасной межсервисной коммуникации.
Рассматриваются Istio, Linkerd, Cilium и Consul Connect.

\begin{table}[h!]
  \centering
  \caption{Сравнение Service Mesh решений}\label{tab:servicemesh-comparison}
  \begin{tabular}{p{4cm}cccc}
    \toprule
    \textbf{Критерий}    & \textbf{Istio} & \textbf{Linkerd} & \textbf{Cilium} & \textbf{Consul} \\
    \midrule
    Лицензия             & Apache 2.0     & Apache 2.0       & Apache 2.0      & MPL 2.0         \\ \midrule
    Автоматический mTLS  & 5              & 5                & 5               & 5               \\ \midrule
    JWT-валидация        & 5              & 0                & 3               & 3               \\ \midrule
    Политики авторизации & 5              & 3                & 4               & 4               \\ \midrule
    Производительность   & 2              & 5                & 3               & 3               \\ \midrule
    Сложность установки  & 2              & 5                & 3               & 3               \\ \midrule
    Observability        & 5              & 4                & 4               & 4               \\ \midrule
    Traffic management   & 5              & 3                & 4               & 4               \\ \midrule
    Multi-cluster        & 5              & 5                & 5               & 5               \\ \midrule
    Документация         & 5              & 5                & 4               & 4               \\
    \bottomrule
  \end{tabular}
\end{table}

Istio предоставляет наиболее полный набор функций, включая продвинутую валидацию JWT и гибкие политики авторизации (оценка 5),
но требует больше ресурсов и имеет более высокую сложность установки (оценка 2).
Linkerd оптимизирован для простоты и низкого потребления ресурсов (оценка 5), но не поддерживает JWT-валидацию на уровне сети (оценка 0).

Istio выбран благодаря наиболее широкому функционалу безопасности,
интеграции с внешними IdP и богатым возможностям для управления трафиком, несмотря на повышенные требования к ресурсам.

\subsection{Observability Stack}\label{subsec:1.2.3}

Для логирования и мониторинга сравниваются стеки на основе различных технологий:
Victoria Logs+Vector, Loki+Promtail, ELK Stack и Opensearch+Fluentd.

\begin{table}[h!]
  \centering
  \caption{Сравнение систем логирования}\label{tab:logging-comparison}
  \begin{tabular}{p{4cm}cccc}
    \toprule
    \textbf{Критерий}    & \textbf{VictoriaLogs} & \textbf{Loki} & \textbf{ELK} & \textbf{Opensearch} \\
    \midrule
    Лицензия             & Apache 2.0            & AGPL 3.0      & Elastic 2.0  & Apache 2.0          \\ \midrule
    Производительность   & 5                     & 5             & 2            & 3                   \\ \midrule
    Полнотекстовый поиск & 4                     & 3             & 5            & 5                   \\ \midrule
    Индексирование       & 5                     & 5             & 4            & 4                   \\ \midrule
    Helm Chart           & 5                     & 5             & 5            & 5                   \\ \midrule
    Интеграция с Grafana & 5                     & 5             & 4            & 4                   \\ \midrule
    Стоимость хранения   & 5                     & 5             & 2            & 3                   \\ \midrule
    Сложность настройки  & 5                     & 5             & 2            & 3                   \\ \midrule
    Сжатие данных        & 5                     & 4             & 3            & 3                   \\
    \bottomrule
  \end{tabular}
\end{table}

Victoria Logs объединяет преимущества различных подходов:
минимальное потребление ресурсов (оценка 5) благодаря эффективной реализации на Go,
полнотекстовый поиск с поддержкой LogsQL (оценка 5) и исключительное сжатие данных (оценка 5), превосходящее Loki.
Решение распространяется под лицензией Apache 2.0 (оценка 5),
в отличие от ELK с его Elastic License 2.0, ограничивающей коммерческое использование (оценка 3).

Loki также показывает хорошие результаты по ресурсам и стоимости хранения за счет индексирования только меток (оценка 5),
но уступает в возможностях полнотекстового поиска (оценка 3).
ELK предоставляет мощный поиск (оценка 5), однако требует значительных ресурсов (оценка 2) и имеет лицензионные ограничения.

Victoria Logs выбран как оптимальное решение,
обеспечивающее баланс между производительностью, функциональностью и эксплуатационными затратами.
Нативная интеграция с Grafana, совместимость с Vector для сбора логов и возможность горизонтального масштабирования
делают Victoria Logs идеальным выбором для микросервисной архитектуры.
Дополнительным преимуществом является экосистемная совместимость с Victoria Metrics для метрик,
что упрощает операционное управление стеком.

Для сбора и хранения метрик сравниваются решения на основе различных подходов:
Prometheus (эталонная реализация), Victoria Metrics, Thanos (расширение Prometheus) и Mimir.

\begin{table}[h!]
  \centering
  \caption{Сравнение систем мониторинга метрик}\label{tab:metrics-comparison}
  \begin{tabular}{p{4cm}cccc}
    \toprule
    \textbf{Критерий}              & \textbf{Prometheus} & \textbf{VictoriaMetrics} & \textbf{Thanos} & \textbf{Mimir} \\
    \midrule
    Лицензия                       & Apache 2.0          & Apache 2.0               & Apache 2.0      & AGPL 3.0       \\ \midrule
    Совместимость с Prometheus     & 5                   & 5                        & 5               & 5              \\ \midrule
    Производительность             & 3                   & 5                        & 3               & 4              \\ \midrule
    Долгосрочное хранение          & 2                   & 5                        & 5               & 5              \\ \midrule
    Helm Chart                     & 5                   & 5                        & 5               & 5              \\ \midrule
    Интеграция с Grafana           & 5                   & 5                        & 5               & 5              \\ \midrule
    Простота настройки             & 5                   & 5                        & 2               & 3              \\ \midrule
    Горизонтальное масштабирование & 2                   & 5                        & 5               & 5              \\ \midrule
    Сжатие данных                  & 3                   & 5                        & 4               & 4              \\
    \bottomrule
  \end{tabular}
\end{table}

Prometheus является де-факто стандартом для мониторинга в Kubernetes (оценка 5 по совместимости и простоте настройки),
однако имеет ограничения в области долгосрочного хранения (оценка 2) и горизонтального масштабирования (оценка 2).
Решение оптимизировано для краткосрочного хранения метрик с локальным дисковым хранилищем.

Victoria Metrics демонстрирует превосходные показатели по всем ключевым метрикам производительности:
минимальное потребление ресурсов (оценка 5) за счет эффективной реализации на Go,
исключительное сжатие данных (оценка 5), превосходящее Prometheus в 7–10 раз,
высокая скорость выполнения запросов MetricsQL (оценка 5).

Thanos и Mimir решают проблему долгосрочного хранения Prometheus (оценка 5), используя объектные хранилища (например, S3),
однако требуют более сложной настройки (оценки 2 и 3 соответственно) и дополнительных компонентов.

Victoria Metrics выбран как основное решение для сбора и хранения метрик благодаря
оптимальному сочетанию производительности, простоты эксплуатации и функциональности.
Полная совместимость с Prometheus экосистемой, нативная поддержка долгосрочного хранения,
минимальные требования к ресурсам и единая экосистема с Victoria Logs для логирования
делают это решение идеальным для микросервисной архитектуры с ограниченными ресурсами.

\subsection{Язык программирования}\label{subsec:1.2.4}

В рамках исследования планируется разработка специализированного микросервиса аудита для централизованного сбора,
обработки и хранения продуктовых событий.
Выбор языка программирования для реализации микросервиса является важным архитектурным решением,
влияющим на производительность, потребление ресурсов и скорость разработки.

Для сравнения рассматриваются наиболее популярные языки программирования в области разработки микросервисов:
Go, Java, C\#, Python и Rust.

\begin{table}[h!]
  \centering
  \caption{Сравнение языков программирования для микросервисов}\label{tab:languages-comparison}
  \begin{tabular}{p{4.5cm}ccccc}
    \toprule
    \textbf{Критерий}                & \textbf{Go} & \textbf{Java} & \textbf{C\#} & \textbf{Python} & \textbf{Rust} \\
    \midrule
    Производительность               & 5           & 4             & 4            & 2               & 5             \\ \midrule
    Потребление памяти               & 5           & 2             & 3            & 1               & 5             \\ \midrule
    Конкурентность                   & 5           & 4             & 4            & 2               & 5             \\ \midrule
    Размер бинарного файла           & 4           & 2             & 3            & N/A             & 4             \\ \midrule
    Скорость компиляции              & 5           & 3             & 4            & N/A             & 2             \\ \midrule
    Кривая обучения                  & 5           & 3             & 4            & 5               & 2             \\ \midrule
    Экосистема библиотек             & 4           & 5             & 5            & 5               & 3             \\ \midrule
    Kubernetes интеграция            & 5           & 4             & 4            & 3               & 4             \\ \midrule
    Стандартная библиотека           & 5           & 4             & 5            & 4               & 4             \\ \midrule
    Совместимость с выбранным стеком & 5           & 3             & 3            & 3               & 3             \\
    \bottomrule
  \end{tabular}
\end{table}

Go демонстрирует выдающиеся характеристики для разработки микросервисов:
высокая производительность (оценка 5), сопоставимая с Rust и превосходящая Java,
минимальное потребление памяти (оценка 5) благодаря отсутствию виртуальной машины,
встроенная поддержка конкурентности (оценка 5).
Компактные статические бинарные файлы (оценка 4) упрощают контейнеризацию и развертывание.

Java обладает зрелой экосистемой (оценка 5), однако требует значительных ресурсов памяти из-за JVM (оценка 2)
и генерирует большие образы контейнеров (оценка 2), что критично для микросервисной архитектуры.

C\# с платформой .NET представляет собой сбалансированное решение:
хорошая производительность (оценка 4), приближающаяся к Go и Java благодаря JIT-компиляции и возможности AOT,
развитая поддержка асинхронного программирования через async/await (оценка 4).
Экосистема NuGet и стандартная библиотека получают высшие оценки (оценка 5).
Однако потребление памяти остается высоким из-за .NET runtime (оценка 3),
а размер образов контейнеров больше по сравнению с Go (оценка 3).
Интеграция с Kubernetes возможна, но не столь естественна, как в случае Go (оценка 3).

Python отличается простотой синтаксиса (оценка 5 по кривой обучения) и богатой экосистемой,
но уступает в производительности (оценка 2)
и не имеет полноценной поддержки параллелизма из-за Global Interpreter Lock (оценка 2).

Rust обеспечивает максимальную производительность и безопасность памяти (оценка 5),
однако имеет крутую кривую обучения (оценка 2) и менее зрелую экосистему для микросервисов (оценка 3).

Критически важным фактором является совместимость с выбранным технологическим стеком:
Zitadel, Victoria Metrics и Victoria Logs реализованы на Go (оценка 5).
Использование единого языка программирования для всей AAA-подсистемы упрощает интеграцию,
позволяет переиспользовать библиотеки и обеспечивает единообразие архитектурных решений.

Go выбран в качестве языка программирования для реализации микросервиса аудита благодаря
оптимальному сочетанию производительности, эффективности использования ресурсов и простоты разработки.


\section{Формулирование задачи и гипотезы ее решения}\label{sec:1.3}
% Та же информация, что во вступлении, но больше деталей.
% В файле nrw/4-practice.pdf это уже по сути сделано.
% Чуть-чуть подкорректировать и можно добавлять.

На основе проведенного анализа существующих подходов и инструментальных средств
для построения подсистем AAA в микросервисных архитектурах сформулируем цель, задачи и гипотезы исследования.

\subsection{Цель исследования}\label{subsec:1.3.1}

Целью данного исследования является разработка и реализация компонентов подсистемы аутентификации,
авторизации и аудита для распределенной микросервисной Continuous Delivery платформы,
обеспечивающей безопасное взаимодействие пользователей и сервисов.

\subsection{Задачи исследования}\label{subsec:1.3.2}

Для достижения поставленной цели необходимо решить следующие задачи:

\begin{enumerate}
  \item \textbf{Изучить современные подходы и механизмы обеспечения безопасности в распределенных микросервисных системах.}

  Микросервисная архитектура создает специфические вызовы в области безопасности, связанные с распределенностью системы и множественностью точек взаимодействия.
  Требуется систематизировать знания о существующих подходах к решению задач безопасности в подобных системах.

  \textit{Ожидаемый результат:} Сформированная база знаний о современных подходах обеспечения безопасности в микросервисных архитектурах.
  Проведен сравнительный анализ решений, выявлены их преимущества и недостатки.

  \textit{Гипотеза:} Комбинация Service Mesh для межсервисной коммуникации и IdP для пользовательского доступа
  в связке с OIDC и OAuth 2.0 позволит создать эффективную основу для AAA-подсистемы.

  \item \textbf{Спроектировать архитектуру AAA-подсистемы, включающую компоненты пользовательской и межсервисной аутентификации, авторизации и централизованного аудита.}

  Проектирование архитектуры является критически важным этапом, определяющим успех реализации.
  Необходимо спроектировать систему, которая естественно интегрируется в существующую инфраструктуру платформы,
  обеспечивает требуемый уровень безопасности и сохраняет возможность расширения в будущем.

  \textit{Ожидаемый результат:} Детализированная архитектура AAA-подсистемы с описанием компонентов и их взаимодействия.

  \textit{Гипотеза:} Модульная архитектура AAA-подсистемы с разделением компонентов пользовательской и межсервисной аутентификации,
  централизованным сервисом авторизации и единой точкой сбора аудита обеспечит масштабируемость,
  поддерживаемость и возможность независимого развития компонентов.

  \item \textbf{Реализовать компоненты пользовательской аутентификации и авторизации.}

  Основы безопасности системы — пользовательская аутентификация и авторизация.
  Они обеспечивают контроль доступа конечных пользователей к ресурсам платформы.
  Реализация должна использовать современные протоколы и предоставлять инструментарий для использования в других микросервисах платформы.

  \textit{Гипотеза:} Использование готового Identity Provider с поддержкой OIDC и управлением доступа
  на основе прав и ролей позволит реализовать безопасную и удобную аутентификацию и авторизацию пользователей.

  \item \textbf{Реализовать компоненты межсервисной аутентификации и авторизации.}

  В микросервисной архитектуре необходимо обеспечивать безопасное взаимодействие между сервисами.
  Это позволит предотвратить несанкционированный доступ к внутренним API\@ и защитить передаваемые данные.

  \textit{Гипотеза:} Использование Service Mesh технологии позволит с минимальными усилиями реализовать
  безопасный и проверенный способ межсервисного взаимодействия на основе mTLS\@.

  \item \textbf{Реализовать компоненты аудита и мониторинга.}

  Аудит и мониторинг позволяют автоматически обнаруживать инциденты,
  способствуют расследованиям нарушений и прохождению проверок у регуляторов.
  Также эти компоненты отображают происходящие события в системе,
  что полезно в случае неполадок или неправильного использования платформы.

  \textit{Гипотеза:} Реализация централизованной системы аудита на основе агентов-сборщиков логов,
  публикующих события в message broker с последующей доставкой в систему индексирования и аналитики,
  обеспечит надежный сбор, хранение и анализ событий безопасности при сохранении производительности системы.

  \item \textbf{Провести апробацию разработанной AAA-подсистемы.}

  Апробация необходима для проверки корректности реализации, соответствия требованиям и оценки эффективности решения.
  Апробация включает развертывание подсистемы в Kubernetes кластере,
  проведение функционального тестирования и нагрузочного тестирования.

  \textit{Гипотеза:} Разработанная AAA-подсистема будет соответствовать требованиям безопасности,
  обеспечивать приемлемую производительность и успешно интегрироваться с архитектурой Continuous Delivery платформы.
  Ожидаемые показатели: задержка аутентификации < 100 мс для 95-го процентиля, пропускная способность > 1000 запросов/сек.
\end{enumerate}

Решение сформулированных задач позволит создать комплексную подсистему AAA,
обеспечивающую высокий уровень безопасности при сохранении приемлемой производительности
и удобства разработки для команд, работающих с платформой.


\section{Выводы по главе \thechapter}\label{sec:1.4}
% Выводу по всей главе.
% Акцентируем внимание на исследованиях, выбранных инструментальных средств.
% Упомянем, что сформулировали задачи и гипотезы.
% В двух словах, реально вывод по главе и всё.

В данной главе проведен систематический анализ подходов к построению подсистем аутентификации, авторизации и аудита в микросервисных архитектурах.
Выполненный обзор литературы и существующих решений позволил выявить ключевые проблемы обеспечения безопасности в распределенных системах и определить эффективные подходы к их решению.

Основные результаты главы:

\begin{enumerate}
  \item Проведен анализ моделей контроля доступа (DAC, MAC, RBAC, ABAC) и установлено,
  что для микросервисных архитектур наиболее эффективным является комбинированный подход,
  сочетающий RBAC для базового управления и ABAC для гибкой настройки политик доступа.

  \item Исследованы стандартизированные протоколы аутентификации и авторизации (JWT, OAuth 2.0, OpenID Connect)
  и обоснована необходимость применения централизованных Identity Provider для обеспечения
  единой точки аутентификации и упрощения управления идентичностями в распределенной системе.

  \item Рассмотрены подходы к обеспечению безопасной межсервисной коммуникации.
  Показано, что концепция Zero Trust и использование mutual TLS являются основой для защиты взаимодействия между микросервисами.
  Установлено, что Service Mesh технологии (Istio, Linkerd, Cilium) значительно упрощают реализацию mTLS,
  автоматизируя управление сертификатами и предоставляя декларативные механизмы для определения политик безопасности.

  \item Проанализированы архитектурные паттерны сбора и обработки логов в микросервисных системах.
  Выявлено, что паттерн с logging agent и асинхронной доставкой через message broker обеспечивает
  оптимальный баланс между надежностью, производительностью и изоляцией компонентов.

  \item На основе выделенных критериев (тип лицензии, интеграция с Kubernetes, зрелость, активность сообщества, производительность, возможность включения в реестр отечественного ПО)
  проведено сравнение альтернативных инструментальных средств.
  Для реализации подсистемы AAA выбраны: Zitadel (Identity Provider), Istio (Service Mesh),
  Victoria Logs+Vector+Grafana (система логирования), Victoria Metrics (система метрик) и Go (язык программирования для микросервиса аудита).
  Выбор Zitadel обоснован оптимальным балансом функциональности и эффективности использования ресурсов.
  Victoria Logs и Victoria Metrics обеспечивают высокую производительность при минимальных эксплуатационных затратах.
  Go выбран благодаря встроенной поддержке concurrency, минимальному потреблению ресурсов и экосистемной совместимости с остальными компонентами AAA-подсистемы.

  \item Сформулированы цель, задачи и гипотезы исследования.
  Определено, что целью является разработка компонентов подсистемы AAA для микросервисной Continuous Delivery платформы.
  Выделены шесть основных задач, для каждой из которых предложены проверяемые гипотезы решения.
\end{enumerate}

Результаты анализа создают теоретическую и методологическую основу для проектирования
и реализации подсистемы AAA, которые будут представлены в последующих главах работы.
