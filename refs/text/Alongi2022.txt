Received: 17 May 2021

Revised: 14 April 2022

Accepted: 28 May 2022

DOI: 10.1002/spe.3116

RESEARCH ARTICLE

Event-sourced, observable software architectures:
An experience report
Francesco Alongi1 Marcello M. Bersani1 Nicol√≤ Ghielmetti1
Raffaela Mirandola1 Damian A. Tamburri2
1

Dipartimento di Elettronica,
Informazione e Bioingegneria - DEIB,
Politecnico di Milano, Italy Milano,
2

Jheronimus Academy of Data Science JADS, Eindhoven University of
Technology, Eindhoven, The Netherlands
Correspondence
Marcello M. Bersani, Politecnico di
Milano, Milano, Italy.
Email: marcellomaria.bersani@polimi.it

Abstract
The speeding growth of the IT market and the spreading of disruptive technologies are leading towards more and more risky operations in need of constant
upkeep, monitoring as well as proactive orchestration. On the one hand, the
property allowing a system to be catered by automated monitoring and healing
technology is defined as observability . On the other hand, appropriate design
principles to manifest observability were originally referred as event sourcing by
its inventor Martin Fowler and warrant for the aforementioned sustainable software operations. Both event sourcing and observability are complex to leverage
on and design for. In an effort to understand more on both concepts, we offer
an experience report on their practical use, featuring: (1) a rigorous definition of
software architecture observability and a set of principles to design for observability using augmented forms of well-known design patterns in line with event
sourcing; and (2) an impact analysis in the context of a case study. Our study
reveals several interesting notions around the concept of observability but our
findings also make explicit new architecture trade-offs that software architects
and stakeholders need to consider as first-class architecture-level concerns.
KEYWORDS
design principles, event sourcing, software architecture observability, software practice and
experience

1

I N T RO DU CT ION

Software systems nowadays are reaching an unprecedented size and scale with more and more stringent
Quality-of-Service (QoS) requirements as well as service continuity conditions and costs.1 At these magnitudes, monitoring and discontinuity management in such stringent conditions become even more critical2-4 and their effective
provision demands proper tooling and code instrumentation. The portfolio of vendors selling off-the-shelf solutions
is rather wide and the offer they provide includes various types of products. Software products for monitoring ranges
from solutions providing few yet advanced functionalities (e.g., Logstash5 for logging) to complex platforms supplying
monitoring-as-a-service (e.g., Dynatrace,6 Splunk,7 Grafana Labs,8 Apache Skywalking9 ) that allow system administrators
to identify problems, receive runtime alarms and monitor the health of the system by means of rich control dashboards.
This is an open access article under the terms of the Creative Commons Attribution-NonCommercial License, which permits use, distribution and reproduction in any
medium, provided the original work is properly cited and is not used for commercial purposes.
¬© 2022 The Authors. Software: Practice and Experience published by John Wiley & Sons Ltd.
Softw: Pract Exper. 2022;52:2127‚Äì2151.

wileyonlinelibrary.com/journal/spe

2127

2128

ALONGI et al.

Since 2018, the new term observability has been circulating in blogs and talks of the software engineering community
and became trending topic among the companies providing distributed systems monitoring solutions. Observability has
been considered from then on as a natural evolution of monitorability and has been associated with a practice that goes
beyond the mere collection of telemetry data of a running application to estimate its performance. Observability should in
fact guarantee a more granular real-time picture of the performance of the system under observation and of the possible
problems arising during execution. Although observability may seem to be a synonym of monitorability, the community
has always tried to keep the two concepts distinct from each other since the beginning. In Reference 10 it is clearly
highlighted how the term observability denotes a property of a system while monitorability is the act of observing (the
performance or health of) a system over time.11 Observability is therefore a measure of how much and well the internal
state of a system can be inferred through a monitoring infrastructure.11 The more observable a system is, the more relevant
and useful the information extracted from monitoring is. For this reason, observability gained interest because it gives
system administrators a greater control over the system as it enables a knowledgeable approach to monitoring.
Although the aforementioned sources give a better insight into the concept of observability, mainly by describing which data are typically considered by the infrastructure that realizes observations (metrics, traces and logs‚Äîsee
Section 2), they fail to provide a more general point of view on the concept of observability. Observability is in fact presented in a way that makes it appear as a specific property of service-based distributed applications and has never been
adapted to different contexts. In addition, they do not clarify what is meant by ‚Äúinference‚Äù or ‚Äúestimation‚Äù of the state of an
application. For the above reasons, extending the analysis of observability to a more general domain where applications
are not necessarily service-driven and distributed is entirely reasonable.
The correlation between properties (functional and non-functional) of an application and the architecture has been
acknowledged by the software engineering community and over time has become an established principle. Considering
a quality attribute to be a measurable or testable property of an application, ‚ÄúWhether a system will be able to exhibit
its desired (or required) quality attributes is substantially determined by its architecture‚Äù.12 Adopting the interpretation
proposed by Bass et al.,12 it is therefore valid to state that an application is observable if its architecture has specific
structures (in the sense of Reference 12, a structure is the set of functional elements and relations between them that
determine the architecture) that make it concrete.

1.1

Overview of the work

In view of the above, we report on our experience in designing for and quantifying observable software architectures.
From a motivational perspective, we recognize the intrinsic difficulty of making modern software architectural designs
consistent with such properties, which often reflect conflicting design choices and still under-explored trade-offs. For this
reason, we intend to identify what is the essential architectural scheme that an application must implement in order to be
observable. Before doing this exercise, our investigation first proposes a definition of observability that is as general as possible and that is not directly ascribed to the world of self-adaptive and distributed applications. Our main outcome is that
designing and catering for observability require specific and granular architectural solutions such as event sourcing,13-15
that can be concisely exemplified as ‚ÄúCapture all changes to an application state as a sequence of events‚Äù * . Event sourcing
enables the continuous, incremental, and iterative improvement of the service functionalities in a DevOps fashion16 by
making service operations and their state explicit, in the form of analyzable event traces.17 At the same time, however,
designing for observability and adopting event sourcing are hard at best and represent, to date, a trial-and-error endeavor,
with little to no reference approaches, tools, and techniques for designers to practically exploit as well as a myriad of possible problems.14,15 In fact, event sourcing has always been described in general terms and it has not been accompanied
by a formal definition.
In seeking to shed light over the aforementioned design process and its outputs, we enacted a mixed-methods study
recapped in Figure 1.
Specifically, the figure uses an input-output flow-graph to highlight how we matched our general research objectives, as previously introduced, with research methods (middle-column in the flow-graph) and practical research outputs.
Figure 1 highlights that, on the one hand, our general research goals are to address the problem of designing for software architectures which are‚Äîat the same time‚Äîevent-sourced and observable. On the other hand, we interpret the act
of software design as the process of making software architecture decisions which are as informed as possible, therefore
*

https://martinfowler.com/eaaDev/EventSourcing.html.

ALONGI et al.

FIGURE 1

2129

Event-sourced, observable software architectures: study overview

requiring a quantification of the effects behind deciding for event sourcing as well as high-observability. At the same time,
we interpret software architecture decision-making as the act of adhering‚Äîmore or less strictly‚Äîto sound design principles and practices prescribed by any given technology, in our specific instance, event sourcing and high-observability
software architectures.

1.2

Main results

From a methodological perspective, we first analyse‚Äîwith a method tailored from formal concept analysis18 ‚Äîavailable
definitions of event sourcing and high-observability software architectures to attain a formalization of the concept. Subsequently, we instantiate a practical and general overview of the aforementioned definition using the metamodeling and
conceptual modeling procedure defined by Schewe et al.19 Finally, we operate a feasibility study via a proof-of-concept
development exercise.20 In particular, (1) we provide our formal definition of monitorability and observability from an
architectural perspective in Section 3. This definition draws from previous work where we provided an outline of how
observability can be made concrete in a classical architectural pattern like model-view-controller (MVC),21 by showing a pattern refactoring that provides observability-by-construction. Subsequently, we introduce observability by design
through event sourcing and carve our approach to observability by applying the insights collected in Section 5. We investigate the abstractions necessary for making an architecture observable, hence distilling event sourcing design principles.
To this end, we introduce a metamodel that includes the core entities essentials to build observable architectures. Also, we
select suitable design patterns to materialize the introduced abstractions into tangible software components that allowed
us to refactor MVC. (2) Finally, we study the cost of implementing observability in Section 6. To quantify the results of our
experience, we present a first step towards a complete evaluation of the benefits and drawbacks of observability and event
sourcing at the architecture level. We offer an impact evaluation of observable architectures through: (i) an experimental
comparison study through a proof-of-concept implementation of observability adopting a service-oriented architectures
(SOA) architectural style22 and contrasting the results with a related work23 based on the Client-Server architectural style;
(ii) an architecture-based cost analysis featuring Function-Point counting; (iii) a comparative analysis with metrics and
measurements obtained by analysing our code through the CodeMR‚Ä† software quality measurement platform.
Our results indicate that observability is costly to design for, adding an increased effort of at least a factor >0.5 in
at least 50% of the COSMIC function types24 and yields an additional potential maintenance cost which remains currently unknown. Introducing event sourcing in a non-observable architecture highlights some technical problems that
the developer has to face in order to incorporate it, hence making the application observable. Firstly, since our definition
of observability implies the presence of a mechanism that captures changes in the state of an application component upon
the occurrence of specific events involving it, the developer must first address a conceptual problem, that is, identify the
relevant events that induce a change in the state of the application and, at the same time, the portion of the state of the
application that undergoes the change and therefore needs to be tracked. Secondly, the developer is faced with a purely
engineering problem that takes the form of implementing a series of functionalities to create a mechanism for tracking
state changes. Event sourcing is in fact more an approach than a pattern; indeed, there is no a clear and precise publicly
available model explaining the necessary abstractions to implement an Event sourced application (details are provided in
‚Ä†

https://www.codemr.co.uk/downloads/.

2130

ALONGI et al.

Section 2). Hence, making observability concrete requires the design and the implementation of a number of abstractions
that must be integrated into the application architecture and not just trivially superimposed. Our experience, which we
propose in Section 6, shows that observability results in an architectural property of an observable application because
the realization of observability requires the development of specific functionalities and functional relationships between
components that the unobservable version of the same application does not have. At the same time, however, observability
makes architectures explainable, and should become a first-class citizen, especially in systems which demand increasingly
the need to explain and expose their operations to the outside world. Altogether, our results encourage both practitioners
and researchers to look further into the notion of architecture observability for automating systems maintainability, and
other relevant Quality-of-Service25 architecture properties in general.

1.3

Structure of the article

Section 2 presents some related works. Section 3 introduces the definition of observability, while Section 4describes the
refactoring of a MVC pattern into an observable architectural pattern. Subsequently, Section 5 presents our research
roadmap, the case study we considered while developing a metamodel of the essential entities that are needed to realize
observable architectures. Section 6 illustrates a first evaluation of introducing observability by design. Section 6.4 presents
the results we obtained, some discussion about our research solution and discusses its threats to validity, while Section 7
concludes our paper.

2
RELATED WORKS AND O BSERVA BILITY: WHY D O WE NEED FO R A
RIGOROUS DEFINITION?
2.1

Observability and monitorability: State of the art and challenges

The state of the art still offers a limited exploration of software architecture observability both from a speculative and
experimental perspective, being observability a quite recent notion in the software engineering community. On the other
hand, several recent works have touched upon cloud architecture complexity and monitorability in terms of microservices governance and management. Most prominently Toffetti et al.26 offer experimental results on managing large-scale
microservices solutions while Galletta et al.27 offer a management solution but in the very specific domain of oceanographic Big Data management and analysis. Furthermore, Tamburri et al.23 offer an operationalization of the concept of
Observability and offer a refactoring exercise that shows how software maintainability improves and at which costs. Further research is offered in this work, which extends23 with a formal viewpoint of observability and monitorability and the
evaluation of the impact of implementing observability in practice.
In Shahin et al.,28 the definitions of loggability and monitorability are offered: the former refers to the process of recording a time series of events of a system at runtime (as in Reference 16), whereas the latter consists of a process of checking
the state of a system. Observability, however, is not mentioned and lacks of a formal definition that can precisely shape
its meaning and distinguish it from the two mentioned properties. Even28 does not offer a formal definition of monitorability, which is generally meant as a procedure that allows for checking system‚Äôs state. Conversely, our definition of
monitorability (see Section 3) is formally stated, and fits perfectly that of Reference 28.
Some recently published articles attempt to better frame the actual definition of observability, mainly focusing on
cloud and distributed service-based applications. All these sources seem to converge on a definition of monitoring (called
Software observability in29 ), consisting in the collection and analysis of system data related to the performance of the
application over time through an appropriate and specific application monitoring system, however not all of them clarify exactly what observability is. While30 conceives observability as ‚Äúa tooling or a technical solution that allows teams to
debug actively their system‚Äù and puts the emphasis on a more managerial aspect of software development (thus conceiving observability as a DevOps tool a team must use to ‚Äúexplore properties and patterns not defined in advance‚Äù),10,11,29,31
agree that observability is a property inherited from engineering and control theory. A closer look at this definition is
therefore worth of mention. The definition of observability by Kalman32 is peculiar to the theory of dynamical systems
and defined through specific properties of differential equations modeling the system. In such a context, the dynamics of a
system is described with time-dependent variables over the Reals that represent internal system states x(t), system inputs
u(t) and system outputs y(t) (the overline represents a vector of variables). A system is observable if it can be described by

ALONGI et al.

2131

T A B L E 1 Available observability patterns in Reference 33
Pattern

Implemented functionality

Log aggregation

Centralized logging service that aggregates logs from each service instance. Searching and log analysis are available

Application metrics A service which collects statistics about operations and provides reporting and alerting
Audit logging

A functionality that records user activity in a database

Distributed tracing

Instrumentation with code that allows services to track every external request with an unique identifier (i.e., to
realize traces)

Exception tracking

Centralized exception tracking service that aggregates and tracks exceptions and notifies developers

Health check API

Endpoint (e.g., HTTP/health) that returns the health of the service
1

means of a system of differential equations in which it is not possible to partition the state variables into two groups x
2
2
1
and x , such that the second group x affects neither the first group x nor the outputs of the system y . In other words,
a system is observable if all the state variables contribute to the definition of the output values. The notion of observability has been adapted to the context of software, and turned into the ‚Äúmeasure of how well internal states of a system
can be inferred from the knowledge of its external outputs‚Äù. Therefore, ‚Äúa system is observable if the current state can be
estimated by only using information from outputs, namely sensor data‚Äù. In the context of distributed service-based applications, observability helps developers identify and resolve performance issues as it allows for ‚Äúexposing the state of an
application‚Äù while it is running. To achieve observability, the community agrees on the use of tools to collect the following
data at runtime: metrics, traces, and logs (they are called ‚ÄúPillars of observability‚Äù). Roughly, a log is a textual description
of an event that happened at a particular time; it includes a timestamp and a payload that provides context. A metric is a
numeric value measured over an interval of time and refers to a quantitative aspect of the application, commonly related
to performance indicators and a trace represents the journey of a request through a distributed system and the functions
implemented therein. In Reference 33 several patterns (summarily described in Table 1) are presented as solutions for
implementing (facets of) observability, that is, that enable the designer to implement the infrastructure that collects metrics, traces and logs. For each pattern,33 shows a brief description of the potential problems that its implementation in
practice may induce. Even if the description is general and does not provide specific details, the problems one faces in
implementing these patterns can be bundled in two main ones: on the one hand, there is the need for significant infrastructure to store traces and logs and, on the other, the intertwining between the pattern code with the business logic of
the application. In the next sections, we try to generalize the notion of observability without overlooking the current literature and attempt to undertake an exercise that allows us to give concrete meaning, through event sourcing, to what
the articles cited above define as inference/estimation of the state of an application.
From an industrial perspective, prominent technical reports from Dynatrace and Twitter highlight the need for specific and organizational-tailored approaches to achieving application observability including an elaborate strategy which
features: (a) organizational elements and clearly defined roles both at Dev and Ops stage; (b) appropriate tooling for
monitoring and closing-the-loop (i.e., feeding runtime information back into design and development-level refactoring
activities); (c) synergistic architectures designed to accommodate both (a) and (b). More specifically, Twitter highlights
the necessity to address their scalable systems observability with a granularity at least at the level of microservice dependencies‚Ä° which is key to maintaining Twitter-base and connected services operational. Conversely, Dynatrace reports that
so-called unknown unknowns require multi-granular observability features and coherent organizational strategy around
the architecture-level constructs. Quoting from Dynatrace: ‚Äú[addressing] the kind of unique glitches that have never
occurred in the past and cannot be discovered via dashboards [lead to] the growing pains that the concept of traditional
observability attempts to tackle‚Äù.
In Reference 34 the author introduces the notion of visibility in the context of network-based applications in which
‚Äúcommunication between components is restricted to message passing35 ‚Äù, or to an equivalent of message passing selected
at runtime based on efficiency criteria and location of involved the components.36 ‚ÄúVisibility, in this case, refers to the ability of a component to monitor or mediate the interaction between two other components. Visibility can enable improved
performance [ ‚Ä¶ ], scalability [ ‚Ä¶ ], reliability [ ‚Ä¶ ], and security [ ‚Ä¶ ].‚Äù Although the concept of visibility seems to be
delineated and distinguished through two specific functionalities, that is, monitoring and mediation, it does not provide
these with a precise definition that makes the concept of visibility clearly defined.
‚Ä°

https://blog.twitter.com/engineering/en_us/a/2013/observability-at-twitter.html.

2132

2.2

ALONGI et al.

Model-view-controller and principal variants

In Section 4 we describe the refactoring of a MVC pattern into an observable architectural pattern. MVC has been the reference architectural pattern for most web-based applications for decades and, given its prominent use, it has seen several
variants. The first variant is known as Model-View-ViewModel (MVVM), that was developed in Microsoft for building
event-driven user interfaces,37 on top of a data-binding technology¬ß . MVVM defines an abstraction, called ViewModel,
besides the classical Model and View abstractions from classical MVC, and rule out the role of Controller, being it replaced
by Binder that automates communication between the view and bound properties in the ViewModel. In essence, Binder
is not a proper component, as it is commonly implemented by means of markup languages, rather it is an underlying
framework which exploits data binding functions (e.g., Windows Presentation Foundation in its first definition). The
purpose of ViewModel is to provide a view of the data in the Model (i.e., a converter) that View can easily manage and
present. It decouples View and Model with a local state, used by the Views to render a proper UI, and a set of commands
used by the Views to signal the occurrence of a user interaction. The execution of the commands causes the ViewModel
to trigger the execution of part of the business logic, which might imply a new application‚Äôs state. When Model change,
ViewModel and View are notified and updated accordingly.
The model-view-presenter (MVP) is another variant of MVC that aims to generalize MVC for building user interface
architectures in Java and C++.38 MVP defines the following abstractions: Model, Command, Selection, View, Interactor,
and Presenter. Model is like the one of MVC, but it mainly stores the state of the application. The application behavior
is outsourced to the Command abstraction, which offers an interface for updating the Model. Selection represents elements of the application‚Äôs state that Commands can change. The purpose of View is the same as MVC, but in MVP, it is
also capable of capturing user interactions through Interactors (in MVC user interaction is captured by the Controller).
Presenter is the coordinator of all the previous abstractions.
To emphasize the difference between our solutions and the known patterns, we point out a list of characteristics of the
patterns that we consider as potential limitations to a correct architectural approach to observability. MVC does not define
distinct abstractions representing the application‚Äôs state and the procedures manipulating it. Model actually groups both
together, limiting decoupling. Moreover, in MVC there is no abstraction to represent external events as the state transition
is enabled by generic messages, exchanged by Controller and Model. model-view-view-model (MVVM) offers similar
features as MVC. Also, since it relies on data-binding frameworks for the event processing, it requires customization if
no underlying frameworks are available. Model-view-presenter (MVP) does not provide an abstraction to decouple the
notion of event and actions that should be taken to handle the event, rather it provides an abstraction ‚ÄìInteractor‚Äì to
signal a user interaction to presenter. Finally, all the MVC-like solutions do not isolate a specific component for tracking
the evolution of the application‚Äôs state along the executions.

2.3

Event sourcing explained

Although the software engineering community lacks rigorous definitions of observability, possibly accompanied by clear
design criteria and defined through precise architectural structures, the industry has been long referring to an architectural pattern whose function is suitable for implementing the notion of observability that we propose in the next section.
This architectural pattern is called event sourcing and has been known in the software development community for a
long time, as shown, for instance, by several blog posts and articles available on the web.39-41
It must be pointed out that event sourcing is not an observability pattern and the goal of this work is not to reconsider its
nature; rather, the goal is to use its feature to implement observability. Event sourcing is, in fact, an approach to managing
the temporal evolution of the application data (or, more in general, of the application state), and can be considered as a
data management architectural pattern. It may be adopted in applications where the data is isolated in a self-contained
entity, such as a dedicated storage object or database, which manages the data by applying operations obtained from
sequences of events to be handled by the application logic. Event sourcing is, in fact, commonly coupled with command
query responsibility segregation pattern to separate read and update operations for a data store in highly performant
and scalable applications.42-44 Citing Fowler, ‚Äúevent sourcing ensures that all changes to application state are stored as a
sequence of events‚Äù.39
¬ß
Data binding is the process that establishes a connection between the app UI and the data it displays. If the binding has the correct settings and the
data provides the proper notifications, when the data changes its value, the elements that are bound to the data reflect changes automatically (https://
docs.microsoft.com/en-us/dotnet/desktop/wpf/data/data-binding-overview).

ALONGI et al.

2133

Developers envision event sourcing as a solution to some limitations of traditional implementations which change
the current state of the data as soon as operations are received (e.g., a CRUD operation), possibly by adopting transaction
mechanisms that lock the data. According to Reference 40, there are possible drawbacks if this approach is used blindly.
Performing operations directly on the database ‚Äúcan slow down performance and responsiveness, and limit scalability,
due to the processing overhead it requires.‚Äù Also, ‚Äúin a collaborative domain with many concurrent users, data update
conflicts are more likely because the update operations take place on a single item of data.‚Äù Finally, no history of the
performed actions can be available, unless auditing mechanisms are specifically implemented.
Even if no common architectural pattern is publicly available, all the sources seem to agree on the presence of a
component called Event Store that performs the persistence of events driving data changes. Event Store implements
publish/subscribe features that allow other application components to get notified about required data modifications.
Event persistency enables replaying events in the store in order to create views of data, to rebuild entirely the current state
of data in case of system failures, or to re-compute the state by reversing the effect of past events that later in the execution
were discovered to be wrong.39 In addition, since events are simple objects that describe some action (together with
context information), and do not alter immediately the data upon their arrival, concurrent data updates can be prevented,
as handling event occurs at the right time and updates are not directly applied to data. As a result, the presentation and
the logic tiers can improve performance and scalability, and the obtained decoupling of the operations on the data from
the event management provides flexibility and extensibility.40
Event sourcing is not a panacea for all the ills and inherently brings some limitations. The delay between the addition
of an event to Event store and the time when consumers handle the event can lead to inconsistency between the current
version of the data and the version obtained by applying the events that have arrived in the meantime. When applications
are complex and maintain several copies of data, or views thereof, in a multi-threaded or concurrent architecture, the
logic of data management must still be able to deal with inconsistencies that result from eventual consistency and from
the fact that the use of transactions is discouraged. In fact, Event store can be used by several distinct components to
create internal views of the data, and strong consistency, when implemented, is often a hurdle to efficiency. Moreover, the
consistency of Event store per se is paramount. Multithreaded application should manage it through suitable mechanisms
(e.g., timestamps), and the reversing of the effect of an event requires suitable mechanisms (e.g., compensating events),
because Event store should never be updated retrospectively as the event history cannot be altered. The interested reader
can find more details in References 39 and 40.
In summary, a mapping between the most essential related work and our contributions and characteristics of our study
are reported in Table 2, which relates all state-of‚Äìthe-art approaches (columns) across the seven essential dimensions
(rows) that the same state of the art has focused upon up to this point, namely, scale, domain-specificity, refactorability, definition operationability, principled design, low-code and application to real-life industrial case-studies. The table
compares major state of the art contributions in the last few years along the lines of the six essential characteristics either
introduced by or claimed as open limitations within each of the aforementioned works. Overall, our synthesis reflects the
need for more precise and rigorous definitions and tool-support as well as design constructs to approach a more varied
and comprehensive notion of observability are required and both the state of the art and practice cannot currently deliver
properly on such required constructs. We argue that designing for observability is a required stepping stone as part of
any DevOps process supporting a sufficiently complex architecture that would justify the extra architecture rigour. Our

T A B L E 2 State of the art, an overview and comparative analysis
Related work
Features

26

27

23

28

34

32

Our work

Analysis at scale

‚úì

√ó

√ó

√ó

√ó

√ó

√ó

Multidomain

√ó

√ó

√ó

√ó

‚úì

‚úì

‚úì

Refactoring focus

√ó

√ó

‚úì

√ó

√ó

√ó

‚úì

Defining

√ó

‚úì

√ó

‚úì

‚úì

‚úì

‚úì

Design principles

√ó

‚úì

‚úì

‚úì

√ó

‚úì

‚úì

Model-driven/low-code

‚úì

√ó

√ó

√ó

√ó

√ó

‚úì

Real case-study

√ó

‚úì

√ó

‚úì

‚úì

√ó

‚úì

2134

ALONGI et al.

contributions start from such a definition and work to provide solid and tested-true principles that can aid in refactoring
architectures towards increased observability. Also, our results aid in providing architecture-level constructs that help
software architects and other DevOps stakeholders address such additional architecture rigour.

3

SOFTWARE A RCHITECTURE O BSERVABILITY

The lack of a precise definition of observability and monitorability of software has been carrying on the discussion in
the community about which aspects actually distinguish a monitorable application from an observable one. Several are
the attempts towards the provision of a precise understanding of observability and monitorability, that have been mainly
shown by practitioners through a mottled amount of blog posts and articles¬∂ . We provide a more theoretical interpretation
of observability and monitorability by reinterpreting the common understanding of these two aspects through an abstract
representation of the behavior of (software) systems.

3.1

Definition

Consider an implementation a, and let S be the state space determined by all the possible configurations of the memory
that are determined by a running instance of a . The definition of S is not limited to the ‚Äústatic‚Äù variables rather it is
general, and an element of S can be seen as the memory footprint of a at a given time throughout the execution (including
i

CPU registers). Let I be the set of instructions in a, and let ‚àí‚àí‚àí‚àí‚àí‚Üí‚àà S √ó S √ó I be the transition relation determined by
i

the implementation a, which is such that s ‚àí‚àí‚àí‚àí‚àí‚Üí s‚Ä≤ holds when the execution of instruction i from state s modifies
the application state into s‚Ä≤ (let ‚Üí‚àó be the transitive closure of ‚Üí ). We say that a sequence of states s0 , ‚Ä¶ , sn‚àí1 in S
i

i

is an execution of a if the states are pairwise related through ‚àí‚àí‚àí‚àí‚àí‚Üí, that is, that are such that si ‚àí‚àí‚àí‚àí‚àí‚Üí si+1 for every
0 ‚â§ i < n ‚àí 1, and s0 is an initial state. Let E be the set of all the executions of a . Consider, for instance, a code including two
integer variables called x and y and that a state of a running instance of the application is defined by the tuple (x = 2, y = 5).
Assume that variable x is incremented by means of instruction x = x + 1 . Hence, we can write the state transition as
x=x+1

(x = 2, y = 5) ‚àí‚àí‚àí‚àí‚àí‚Üí (x = 3, y = 5) .
In the following the definition of monitorable and observable application is provided. Let U be a subset of E . Intuitively, the subset U is the set of executions in E satisfying specific (nonfunctional) properties such as, for instance, CPU
intensive executions because of specific input data or particularly unfavorable execution environment. In this scope, the
following definition applies.
Definition. We define an application a as monitorable if there exists an implemented function fm from E to the
set of natural numbers N that indicates if an execution of a running instance of a belongs to U. Conversely, we say
that application a is observable if, given an execution s0 , ‚Ä¶ , sn‚àí1 , there is a function fo from N to S that is equal to si
if i is a position of the execution.
Stemming from the definition, the goal of monitorability and observability can be clearly plotted. While the former
aims at providing functionalities that enable the identification and classification of the executions of an application, the
latter only supplies a detailed view of the application state at a given position throughout an execution. In other words,
an application is monitorable if there is an implemented functionality (i.e., function fm ) which can evaluate at runtime
the value of some software-related metrics that the current execution of the application is determining. Among many,
we can mention for instance, the CPU usage, the memory footprint, the number of incoming requests per seconds, the
number of delivered outcomes per seconds and so forth. The definition of U is general in the previous definition, whereas
the common understanding is more specific. Set U, in fact, usually includes the executions that might generate future
failures, or indicate unhealthy configuration of the runtime environment. It becomes clear when one or more metrics
are selected and their characterization is given. For instance, set U can be the set of all the executions of the monitored
¬∂

https://landing.google.com/sre/book/index.html.

ALONGI et al.

2135

application (or component, function, service, etc.) such that the service output rate is less than 1 million processed requests
per seconds. For this reason, the occurrence of an execution in U should be recognized by monitoring components, and
properly managed at runtime, to avoid unpredictable evolutions or performance drop. We can assume that the natural
value returned by function fm is associated with a specific ‚Äúexplanation‚Äù that characterizes the criticality of every execution
in U . By using this information, specific components can react proactively to prevent failures, or to improve the health
of the application, as soon as the monitoring components detect a problem. This interpretation is fully compatible with
the definition in Reference 28, and the common understanding of monitorability.
Observability has a different goal, that is complementary to the one of monitoring. Observability, in fact, is not a
substitute for monitoring, nor does it obviate monitoring. An observable application has in fact specific components that
make the reconstruction of the state of the application possible, whatever position throughout an execution is selected.
The information obtained from function fo can complete the one provided by the monitoring components implementing
fm , hence allowing for a better understanding of the causes that negatively affect a running application. In minimalist
terms, an application is observable when any change in its state is recorded in a log, along with the event that caused the
change.
Our definition of application is general, and it does not tie the term to one instance of a program. Indeed, by enlarging the scope of term application, we can include, for instance, operating systems or virtual machines that take care of
the execution of several distinct applications, but also services or distributed stateful functionalities. Therefore, when
observability has a larger scope than a single application instance, the information that can be collected by means of fo
can be very rich, and provide insights into the behavior of a specific application along with a rich context, determined by
a complex environment that might include several concurrent applications.
From a practical perspective, fm and fo can hardly be implemented when the size of the implementation a is realistic. Procedure for monitoring or observability cannot watch over everything, and their implementation can become so
complex and pervasive that use and maintenance can become complicated and costly. Indeed, the burden of tracking too
many details of state of the running application can have a drastic impact on the performance, and can easily lead to a
misuse of resources. Monitorability and observability in practice are attained by considering a proper projection of the
application states. A possible projection, that can be implemented at the application level (i.e., that does not require low
level calls to the SO), can be defined as follows. Let V be the set of all variable identifiers that occur in a, and let V ‚äÜ V be
a subset. Given a state s ‚àà S, the projection of s on V, indicated as ùúãV (s), is the portion of state s only related to the variables in V (we can assume that different values in s that are bound to the same variable identifier, for example, because
they reside in distinct activation records, are distinguished by a suitable indexing).
We exemplify our interpretation of observability by interpreting the term ‚Äúapplication‚Äù as ‚Äúclass‚Äù. Consider the class
X, whose implementation is shown in Figure 2, which includes an attribute att and a method f . Intuitively, class X is
observable if it is possible to observe, that is, record, the effect of the execution of f on the value of attribute att, for a
specific instance of X . Since only the instruction at line 7 can change the value of att, if the value of the attribute att is
recorded after every call of method setter, the effect of f is fully observable.

FIGURE 2

Observable code snippets; an example

2136

3.2

ALONGI et al.

Implementing observability through event sourcing

Event sourcing represents an approach to observability; if suitably employed, it allows to achieve observability by design.
In fact, the function fo can be effectively implemented by adopting event sourcing as an archetype that allows developers
to identify the main entities that together provide observability. To obtain observability, an application can implement an
event store component which records all the relevant events that entail a state change. Hence, the presence of a log of
events and a state si makes it possible to compute state sj by replaying the events from i . The granularity of the observations
that determine the definition of the events is application dependent. It is up to the developer to identify the proper set of
events that should be observed, together with their nature and composition. The nature of an event, in fact, can be a single
statement or even a sequence of function calls; and, transversely, an event can be determined by a nontrivial composition
of occurrences such as, for instance, two function calls f and g, one following the other within a given context (e.g., f
returns some data). Therefore, implementing (or refactoring to attain) observability via event sourcing is far more than a
log that records events driving a state change, but it requires the recognition of:
‚Ä¢ the part of the application (e.g., the components) which determines the projection of the application state to be
observed, and that change their internal state upon the occurrence of an event,
‚Ä¢ the events, their nature and composition; and the context that they bring over, that is, the information they use to
realize the state change,
‚Ä¢ the entity that enforces a state change in those that are affected by the occurrence of an event,
‚Ä¢ the entities that provide the logic to handle an event, and finally,
‚Ä¢ the entity that realizes the information persistence, which renders the information realizing the projection of the
application state and the events that drive the state changes into a machine readable log, and that allows for the
reconstruction of the application‚Äôs state.
Our definition of observability is general enough and the patterns presented in Section 2 can all be seen as an instance
of our definition. For every observability pattern presented in Section 2 and described in Reference 33, we can characterize
what constitutes the concept of state, which are the events that reasonably might be those inducing a state change to
be recorded and which is the source/entity that can cause the events. The latter two entities in the list of elements that
designers should identify to implement observability via event sourcing (presented above), that is, the one providing the
logic to handle an event and the one realizing information persistence, are not shown because their functionality is general
and does not depend on the specific pattern‚Äôs functionality. In other words, we safely assume that all patterns may be
considered to implement a logger and some control logic to deal with events and to enforce a state change. The result of
this analysis is shown in Table 3. The column ‚ÄúState‚Äù describes which notion of state is being considered in a pattern and
that should be observed in order to realize the pattern‚Äôs functionality. The column ‚ÄúEvents‚Äù suggests possible relevant
events that determine changes of the state. Finally, the column ‚ÄúSource‚Äù indicates viable entities that might trigger the
events relevant to the functionality realized by the pattern.
In Section 5.3, we show a metamodel which captures all the relevant entities that can be used to implement observability by an event sourcing based approach, and how the abstractions can be mapped to software components. Since
there are no precise abstract models capturing event sourcing we implement the mapping by using a well-know design
pattern called Command.

4

OBSERVABILITY AS AN ARCHITECTURE Q UA LITY: THE MVC CASE

The definition of observable application that we set forth in Section 3 is abstract, and cannot be immediately transferred
to a working implementation. Our definition does not actually identify the functional requirements that an observable
application should put into effect, nor establishes how the functionalities realizing observability should be translated into
an architectural pattern.
In general terms, observability can be considered as a software quality that materializes through an integrated implementation of function fo . As already discussed in the previous section, our definition is general, and therefore, it is not
compulsorily restricted to an application or a part of it. Hence, it is perfectly valid to observe an object through a suitable projection of its variables, but also through an entire application. In any case, the integration among the observed

Source

The service request trackers
and/or the centralized
component which records the
requests‚Äô data

The local/centralized exception
loggers

Exception tracking

Similar to the Log aggregation

Similar to the Log aggregation

The information that characterizes the service An occurrence of any service request that
requests to be recorded and, possibly, a
any generic component/service in the
projection of the application‚Äôs state (that
application may have to process
might be collected by other application‚Äôs
components)

Similar to the Log aggregation

Any service/component in the
application

The user interface or any component
that processes input from the user
and its requests subsequent to their
acquisition

Distributed tracing

Every user action

The database instance

User activity database

Audit logging

The information that characterizes an error or An internal or external (w.r.t the application) Every entity of the application that
message to be recorded and, possibly, a
contingency that causes an error or
requires the execution of the logger
projection of the application‚Äôs state (e.g.,
message to be logged and the context that
functionality
division by zero because variable x is null)
can explain the contingency. Events may
not directly generate an error/message but
contribute to its occurrence (other events
that precede the one that triggers the error
but are somehow related to it)

Events

The information that characterizes the metrics The activation of a timed recurrent system‚Äôs The ticker component calling the
to be recorded and, possibly, a projection of
health checking procedure or any generic
system‚Äôs health checking procedure,
the application‚Äôs state (e.g., CPU usage,
functionality requiring system resources
or the system‚Äôs health checking
allocated physical memory, etc.)
(e.g., a timed function call which monitors
procedure itself, and any software
the system health, the occurrence of a
entity that requires system resources
process creation, object allocation, etc.)
and the context that can explain the
contingency

The application‚Äôs loggers

Log aggregation

Observed
entity‚Äôs state

Application metrics The monitoring system

Observed entity

Pattern

T A B L E 3 Framing observability patterns33 into our approach

ALONGI et al.
2137

2138

ALONGI et al.

application entities and the part of the application that realizes fo expects all the involved entities to implement specific functional interfaces, which directly influence their implementation. Since styles and software architectures per
se determine the roles of the implemented entities and their interactions, observability can then shift to the architectural layout of an application and become an architecture quality. Therefore, we say that an architectural pattern
offers observability (or simply, it is observable) when it defines explicit abstractions that fulfill the following functional
requirements (FR):
FR1- operating with a machine-readable representation of a set of variable values, in which the system is observed to be
in any instant during operation,45 and with a machine-readable representation of the events (data input or internal
operations) that have an effect over that variables;
FR2- rendering the architecture state into a machine-readable representation to the outside environment.
Given the need for integration of fo with the observed entities of an application, and its effect on the implementation, any implementation of fo can also be seen as a software ‚Äúaspect‚Äù, being it a feature that lies transversely to both
the core and non-core parts of an application, and that is not directly related to the application‚Äôs primary functions
(i.e., a cross-cutting concern46 ). Besides aspect-oriented design/programming (AOD/P), which is considered as a possible approach to architectural modularity, one can take advantage of off-the-shelf platforms such as Microsoft Azure47
or Eventuate.33 While the former requires no specific introduction, the latter is a platform for developing ‚Äútransactional business applications that use the microservice architecture‚Äù which ‚Äúprovides an event-driven model that is
based on event sourcing and CQRS‚Äù. The platform is based on a SQL database for event persistency and Kafka48 as the
publish/subscribe mechanism (an example application implemented with the open source platform can be found in
Reference 49).
Despite the variety of technological solutions and architectural approaches, the goal we want to pursue in this work
is beyond the mere adoption of a design/programming approach, which we simply consider as a means for developing a
software solution. Our goal is more ambitious, as we want to understand how the abstract notion of observability can be
made concrete, which are the essential software entities and relations that designers should identify to obtain observability, and the cost they come with, regardless of the targeted design/programming approach. To this end, we transfer the
prescriptions identified in the next sections to an effectively modular software architecture of a realistic application, and
we derive a metamodel in Section 5.3, by adopting an inductive reasoning, which characterizes all the essential entities
and relations required to render observability into software. In essence, adopting a different design paradigm is clearly
possible, provided the meta-model elements are mapped to actual software elements that are specific of the selected
approach.
To implement the feasibility study via a proof-of-concept development exercise in Section 5.2, we ultimately opt for
existing architectural styles,50 and we adopt the client-server and component-based styles. Both are very well-known
and popular. In addition, the latter is general enough to be transversal to problem-specific approaches. It is sufficiently
expressive to allow the development of an effectively modular software solution, and it is also common in different programming languages and paradigms. Using a component-based style allows us to render the meta-model entities into
actual components and exploit OO design-patterns.
Finally, after showing the observability meta-model, we evaluate the overall architectural cost of a realistic application
which is induced by the entities and relations in the meta-model that supply for observability.

4.1

Motivations for model-view controller

To offer an authentic example of observability as an architecture quality attribute, we select the most recurrent architectural pattern known to date‚Äîthe classic Model-View-Controller pattern21 ‚Äîand we introduce its refactoring which
provides for observability by-construction.23
The selection of MVC rests not only on its nature of most used design pattern both in practice and research51,52 but,
from a technical perspective, on the following two traits: (1) MVC is the de-facto standard when implementing reactive
web applications and portals, and therefore it reflects the most modern cloud-native digital application architectures
alike; (2) MVC is sufficiently high-level and often referred to as an architecture-level design pattern, since its design rules
may generalize to many subsequent design choices (e.g., the adoption of a client-server approach for specific areas of the
MVC-structured web portal).

ALONGI et al.

2139

T A B L E 4 Mapping of oMVC abstractions
oMVC

MVC

MVVM

MVP

Store

Controller

Binder / View-model

Presenter

State

Model

Model

Model

Resolver

Controller

Binder

Presenter

State policy

Model

Binder

Command/selection

Side policy

-

-

Command/selection

Action

-

-

-

View/normal

View/controller

View/ViewModel

View/interactor

Logger

-

-

-

4.2

Observable MVC explained

Observability actually reflects an ordered set of data transformations53 affecting the state of a running application. Considering the previous arguments and stemming from the definition of Section 3, we need to modify MVC to include the
functional elements that enable event sourcing and that we identified in Section 3.2. In the following, for each of them, we
show which components in MVC achieve the specified functionality, and how they provide it, and which new functional
abstractions not present in MVC are introduced to build an event sourcing -based architecture. We point out first that some
functionalities provided by the MVC components are rearranged in oMVC and mainly split into distinct functionalities
realized by oMVC components. Table 4 shows the relationship among oMVC and the patterns MVC, MVVM and MVP.
Every row indicates the component in oMVC which realizes part of/the same functionality implemented by components
in MVC, MVVM and MVP. The following abstractions materialize the functional elements described in Section 3.2.

4.2.1

Modeling the evolving application‚Äôs state to be observed

The MVC Model provides both the functions (changes to the application‚Äôs state following a request from the controller
component). In oMVC, the State abstraction represents the observed state of the application, that is, the set of pieces of
information that constitute the projection ùúãV defined in Section 3. The latter function is entrusted in oMVC to a functional
abstraction separate from State and dedicated only to the state update function (see state Policy later).

4.2.2

Modeling the events causing a state change and their instantiation

MVC has no abstractions that model events but one, the View, to capture external events (e.g., user‚Äôs requests). In oMVC,
the execution of a business logic paired with entities implementing the Action abstraction entails the evolution of the
application state. Relevant (internal or external) events are intercepted by the View/Normal components, which make
them available to the rest of the architecture as Action. View/Normal components take over the MVC View, adding a more
refined interpretation of this component. oMVC View components intercept external events and produce a representation
of the application‚Äôs state (via the State) to be communicated only to the external world; while oMVC Normal ones take
care of internal events and build a representation of the application‚Äôs state that is intended only for other application‚Äôs
components. Similarly to MVC View, a View/Normal component might produce a new encoding of the application state
whenever the effect of the execution of an Action alters the application state.

4.2.3

Handling events with proper logic

The MVC Controller provides the logic to handle events and controls the execution of the logic realizing the application‚Äôs
state change along with the more general coordination and supervision of the Model and View components. In oMVC

2140

ALONGI et al.

however a finer functional partitioning is considered and the Command pattern.54 is adopted to decouple the logic to handle events from the one enforcing the state change. In the Command pattern, the Command interface usually declares
one method for executing a command and its implementations are instantiated to handle specific requests. The logic that
defines the application‚Äôs state transformations in oMVC, hence including the business logic of the application, is encapsulated into the Policy abstraction, which corresponds to Command interface. Every Policy is equipped with method apply()
which computes a new application‚Äôs state based on the Action to be handled. Policies are categorized into state Policies
and side Policies. The former implements procedures that modify the application state, while the latter implements the
logic of actions which read the state without manipulating it (e.g., querying some information from it). In the Command
pattern, two distinct roles use the command objects: the Sender, which intercepts an event and triggers a computation
to handle it by means of a command, and the Receiver, a component which implements the proper logic to deal with
the event. Nonetheless, part of the logic can also be implemented by the command object itself, complementing, therefore, the part that can reside in the Receiver. In oMVC, Sender is impersonated by the component which triggers a state
change (see Store later), and Receiver is realized by the classes constituting the Model. Besides policies, oMVC includes
the Resolver abstraction, which represents the mapping between an Action and a (state and side) Policy that should be
executed to manage the Action.

4.2.4

Enforcing of a state change upon the occurrence of an event

The MVC Controller provides this function, which is committed to the Store abstraction in oMVC. The Store component
in fact enables the modification of the application‚Äôs state by running the policies (state and/or side) that are identified by
the Resolver component when an Action has to be handled. In addition, the Store component is responsible for notifying
View components about the change, so all the views can provide a new data representation to the external world. Method
propagateAction() in Store implements the logic of a policy that handles an occurred event.

4.2.5

Reconstructing the application‚Äôs state

MVC is devoid of such a functionality. In oMVC the Logger abstraction handles data persistence and abides by Store
instructions, that specify which data have to be recorded and how the application‚Äôs state can be rebuilt. According to
the definition of observability in Section 3, an application is observable if the reconstruction of an occurrence of the
(projected) application state, manifested throughout the execution of the application, is allowed. To implement such a
function, first all the state configurations that occur in an execution should be persisted in a log along with the Actions
that transformed a state into its successor. Second, the reconstruction of an instance of the application‚Äôs state should be
performed using the recorded data in the log. The Logger component, which is activated by the store when a state policy
is issued, guarantees the persistence of the application state Every time a state policy is applied on the state, the store
component can use the getter methods of State to collect the projection of the application‚Äôs state that should be logged,
before and after the execution of the policy. The Logger component records the state change with tuples of the form
(a, si , si+1 ) that include the Action descriptor a, and a representation of the application state si and si+1 before and after
the execution of the (State) Policy, is appended in the log. Action a and the pair of states si and si+1 are both represented
based on a suitable encoding. The application‚Äôs state reconstruction in done by the Store component based on a sequence
of Actions, that are replayed from a position in the log, that is inherently associated with a specific state. We observe that
the definition of the log tuples, as well as the implementation of the function that reconstructs the state, are generic in our
definition. Both, in fact, are implementation specific, and should be customized according to specific design needs. The
State component can include, for instance, simple numerical entities but also complex data structures; whereas Actions
might be basic transformation (e.g., an increment of an index) or more complex operations (e.g., the elimination of a node
in a balanced tree). The application designer should, therefore, adopt the most suitable encoding for representing state
variables and data transformations, and finally identify the best trade-off between the amount of information collected in
the log, and the amount of computation committed to the procedure that restores the application state.
Figure 3 offers the data flow which ensues from our refactored‚Äîand observable‚Äîversion of MVC (i.e., oMVC or
‚Äúobservable‚Äù MVC), introduced in Reference 23. The occurrence of an event outside the application, such as a request for
a data change within the application, or an internal event, is captured by a View component and encoded via an action
object along with the request-specific data. The View notifies the Store component which then requests a policy object

ALONGI et al.

2141

F I G U R E 3 Data flow in oMVC. Boxes represent the main components of oMVC, whereas arrows indicate an information exchange. In
particular, solid lines imply the presence of an instantiated object, such as an action or a policy; or a functional dependency that is realized
between two components (e.g., Apply and Log). Dashed arrows represent generic dependencies that can be designed as
application-dependent features.

from the Resolver component to process the request. The Policy object applies to the current state and calculates the new
application state which overrides the current one through the action of the Store component and the collaboration of
the State component. The application‚Äôs state change is recorded using the Logger component at the behest of the Store
component.

5

ST U DY D E SIG N AN D E XECUTION

As clear from the aforementioned concepts and definitions, designing for, and implementing architectural observability
comprises a considerable cost with still relatively unclear consequences over other key architectural characteristics, such
as maintainability and more. A full elaboration of these consequences and an exploration of best practices and approaches
to manage the architecture trade-offs connected to observability are yet to be uncovered. Consequently, in this article, we
aim to address the following research questions:
RQ0. Which are the abstractions needed for making an architecture observable?
RQ1. What costs are implied when designing for observability?
RQ2. What maintainability consequences does design-for-observability manifest?
In the scope of RQ0, we aim to define the core abstractions that are essential for implementing architectural observability. In the scope of RQ1, we aim at understanding whether there are costs connected to designing for observability and
what those costs might be. Furthermore, in the scope of RQ2, we aim at understanding and measuring the architectural
consequences‚Äîin terms of global architectural software metrics‚Äîthat manifest in connection with a fully-observable
software architecture.

5.1

Research methods

To attain our results, we exploit the work in Reference 23 in which a standard exploratory prototyping approach was
used. While in Reference 23 the aim was on re-implementing a prototype conforming the Client-Server (CS) architectural style, in this study, we focus on a simple yet expressive industrial case, a service-based weather prediction and data
analysis system (description in Section 5.2). This is a distributed service-based application featuring a more elaborated
Service-Oriented Architecture realizing its services through RESTful APIs. The evaluation has been carried out by considering two different implementations of the same case study; one is based on the standard MVC pattern, while the
second builds natively in the oMVC pattern# . Our focus on this rather simplistic case is a specific research design choice.
#

The two implementations are available at https://github.com/nicologhielmetti/weatherdatanalysis_oMVC, https://github.com/francescoalongi/
weatherdatanalysis_MVC.

2142

ALONGI et al.

We intend to explore the impact and consequences of designing for observability in a very simple architecture prototype,
albeit with several appealing and controllable architecture features, such as service-based style or number of components.
We in fact assume that such a simplistic case offers a very optimistic estimation of observability consequences, which are
bound to be higher in more complex systems.
To answer RQ0, we devise a metamodel that includes the core entities which are essential to build observable architectures. For the sake of clarity, the metamodel is presented by explaining its constituents through the new developed
application, yet it reflects all the entities that are proper of oMVC, and in turn, those that implement MVC, MVVM and
MVVP and that can be implemented by oMVC entities (see relation in Table 4).
To explore RQ1, we adopt a state-of-the-art function-point (FP) analysis55,56 approach known as COSMIC, stemming
from an international standard for measuring software size, elaborated on standard ISO/IEC 19761:2011. The count
essentially focuses on data movements and transformations within a software architecture and across components, with
four data movement types, Entry, Exit, Write, and Read that typically require measurement. To further substantiate
the FP counts connected to the COSMIC procedure, two observers were involved using the well-known Krippendorff ùõº
approach.57 The ùõº score essentially measures a confidence interval score stemming from the agreement of values across
two distinctly reported observations about the same event or phenomenon. In our case, the value measures the agreement between the two COSMIC-based FP measurements for the case under study. The value was calculated initially to
be 0.89, hence ùõº > 0.800, which is a standard reference value for highly confident observations. Subsequently, the value
was used to drive the agreement between the two analyses up towards total alignment|| .
Finally, to explore RQ2, we evaluate the comparative analysis with metrics and measurements from the CodeMR
software quality measurement platform, a holistic software measurement platform, which offers a number of software
architecture quality metrics, such as coupling and cohesion between modules.59,60 Subsequently, the measurements in
question were analyzed comparatively with descriptive statistics to evaluate the variance between the two prototypes
connected the observability of one of them.

5.2

Observability implemented: A case-study

The new case study concerns a service-based weather prediction and data analysis system, realized as a three-tier web
application that is intended to collect and store weather data, emitted by remote stations, and supply functionalities for
statistical analysis via the web. The user of the application should be allowed to:
1. create a station in the database;
2. upload data, that is, perform a bulk insert of weather data into the database;
3. download data in a user-defined time window;
4. register a station which periodically pulls data into the database from the URL‚Äôs weather station (the URL and the time
interval are defined by the users at the registration time);
5. query data from the database, so the user can select stations, time window and weather dimension (e.g., temperature),
and compute statistics on them.
The three-tier nature of the web-oriented systems requires a specific customization of the proposed oMVC pattern.
Like MVC, oMVC entities must be implemented as elements constituting the final system architecture, whatever architectural style has been chosen (e.g., client-server, microservices, etc.). oMVC is in fact agnostic to the adopted architectural
style, as it does not come with specific constraints to tackle different architectural styles. In the case of three-tier architectures, the state of an application should generally address several dimensions, each one associated with an application
layer (presentation, application, and storage). In addition, implementing the storage tier by using a database introduces
new challenges, as keeping data integrity between the database and a copy requires the adoption of specific solutions,
and might yield inefficiencies.
We interpret observability in the selected application as follows. The State component consists of two distinct entities
called, respectively, WebAppState and StorageState. The WebAppState component keeps track of the user requests that are
generated in the presentation layer. Every request originates from an HTTPRequest issued by the user and ends when an
HTTPResponse is sent back to the client. Every HTTPRequest/HTTPResponse is collected in the WebAppState in a map,
||

The full analysis tableau can be found online.58

ALONGI et al.

2143

FIGURE 4

A snippet of observability-enabled textual logs

FIGURE 5

Underlying design patterns in the use case application

and is associated with a unique identifier and a corresponding Action, that represents it in the application layer. Every
HTTPRequest coming from the client is described by all its parameters, in order to allow for state reconstruction: they can
include, for instance, the identifier if a remote station, the weather data that are transferred and so forth. The StorageState
component keeps track of all the SQL queries on the database, that are encoded as textual strings to guarantee the database
reconstruction. Logging is carried out according to the rules described in Section 3, and is realized by recording tuples
that include: (a) the Action description, (b) the HTTPRequest description, and (c) the SQL query sent to the database.
A snippet of a log is shown in Figure 4.
Figure 5 shows a partial representation of the class diagram of the oMVC application, colored in black, and an overlay
that identifies the fundamental roles of the two design patterns that underlie the oMVC architecture, namely, the MVC
pattern and the Command pattern. The application exploits several View/Normal classes that are extensions of the Servlet
class (which materialize the View of an MVC architecture). As an example, Figure 5 shows the UploadData servlet,
which handles the HTTP user request ‚ÄúUpload data‚Äù. Every servlet requires the implementation of the method called
onWebAppStateChange(), each one taking care of the construction of the HTTP response message specific to the associated
HTTP user request. The Controller component is functionally realized by the Store component, which exposes a method
called propagateAction() executing the logic that handles an HTTPRequest, captured by a servlet and represented by
means of an Action object. Finally, the components WebAppState and StorageState impersonate the Model of the MVC
pattern (Hibernate is also shown in the figure to clarify the presence of a component implementing persistence of data).

2144

ALONGI et al.

The state reconstruction can be realized by applying stepwise the operations that are specified in every log item on the
WebAppState and StorageState components. In particular, the Action and the HTTPRequest can be used to reconstruct
the maps in the WebAppState, while the queries can be executed incrementally to reconstruct the database, starting from
an empty instance. (A detailed class and sequence diagram of the application are provided in the online appendix58 for
the interested reader.)

5.3

Metamodeling for observability

To answer RQ0, hence to create a metamodel describing an observable architecture, we analyze oMVC in terms of its
underlying design patterns and we identify the abstract roles that enable observability. In doing this exercise, we consider all the functional abstractions identified in Section 3.2 and applied to develop oMVC abstractions in Section 4.2. In
addition, while analysing the abstractions required to materialize event sourcing, we must also pay particular attention
to the role of the Command pattern that we use to separate the logic to elaborate an event from the enforcement of a state
change. The result is the metamodel shown in Figure 6.
We first identify an abstraction for each functional element in oMVC, and therefore assign a metaclass to State, Store,
Policy, Action and Resolver. As explained in Section 4.2, Policies correspond to commands in the Command pattern and
play a fundamental role in separating the logic for processing an event from the application of a state change is crucial in
oMVC. Examining Figure 5, we can see that the association which ties the MVC Controller with the Model and enables
the effect of the controller‚Äôs logic on the application‚Äôs model, is refined in oMVC and transformed into an observable
cause-effect relation. Policy objects make the cause-effect relation effectively concrete. This argument is general, and
can be applied every time a cause-effect relation, that should be ‚Äúobservable‚Äù, exists between two entities, one of which
induces an effect on the other. Based on this analysis, we consider part of the oMVC metamodel the two abstractions
that describe the roles in the command pattern, namely Sender and Receiver. For the sake of uniformity with the oMVC
nomenclature, we name the two abstractions Driver and Target. The Driver abstraction models Store in oMVC and Target
is the abstraction for State. Their semantics reflects the meaning of Store and State in oMVC. A Driver component initiates
a reaction to handle an application‚Äôs event, and the consequence of managing the event determines an effect on a Target
component, which undergoes modification accordingly. The oMVC Action is an instance of the general abstraction called
Event. The occurrence of an Event implies that the logic implemented by a Handler is carried out to realize the effect on
the Target. Handler is the abstraction of the oMVC Policy. The execution of the Handler‚Äôs logic affects some State elements
that contribute to the definition of the state of the Target. The modification realized by the Handler, as well as the event
causing the change, are logged by storing the State element‚Äôs value before and after the execution of the Handler‚Äôs logic.
Several relations exist among the aforementioned abstractions. A peculiar one is handlerResolver between Handler and
Event which is made concrete through the oMVC Resolver. The other relations in the metamodel are the following.

FIGURE 6

oMVC applied on weather forecast application and metamodel

ALONGI et al.

2145

‚Ä¢ handlerAssignment and handles become dependencies between, respectively, Store (Driver class) and the Policies
(Handler classes) that manages events, and Store and Actions (Event classes).
‚Ä¢ handlerEffect materializes through method apply() in Policy classes, whose purpose is to modify State (of a Target class)
using a selected Policy (Handler class).
‚Ä¢ trigger is reflected to method propagateAction() in Store (Driver class). This relation allows Store to apply a Policy
(Handler class) to State (Target class) and possibly calculate a new application‚Äôs state.
‚Ä¢ loggerEnforcement and logger are dependencies between Store (Driver class) and Logger (Logger class), and between
Logger and State (Target class).
‚Ä¢ State includes public methods that can be used to manipulate the application‚Äôs state or public attributes of the State
(Target class). An attribute belongs to a target class through the stateAssignment relation. In essence, State represents
the projection of the entire application‚Äôs state that is observable.

6

EVALUATION

6.1

Costs of observability by design

Table 5 summarizes the FP counts, and connected variations of both the SOA and CS application, respectively (detailed
analysis can be found in the online appendix58 ). As evident, there is a considerable difference between observable and
unobservable architectures; more specifically, the observable version suffers from a double additional gain of costs in half
of the systems function types (Entry and Write functions).
The analysis aims at evaluating the functional requirements FR1 and FR2 that we identified at the beginning of
Section 4, and it has been carried out by considering the granularity at the class level, that is, the classes are the atomic
entities that interact with each other through methods. Since we limit the analysis to the functional requirements FR1
and FR2, the functional points evaluation can be restricted to the class Store and the class Logger. The functional users
of the applications are the external ‚Äúcustomers‚Äù of the application that play their role via Servlet components in the SOA
application, and via the client in the CS application; the edge that separates the external environment from the application materializes through the Servlets and the clients. For this reason, only Store and Logger directly perform a function
to the user of the application while Action, Resolver, and Policy contribute indirectly. Resolver and Policy are functional
with respect to Store while Action is a representation of an event and therefore can be equated more to datum than a
functional element.
The Persistent storage consists of the application log in both the architectural styles and includes also the database
in the SOA application. Since the two versions (observable/nonobservable) of the application provide a different set of
functionalities to the user (i.e., the functionalities that concretely realize the FR1 and FR2 requirements and thus the
observability) it is correct to expect (and see) that the number of function points in both CS or SOA architectural solutions,
show a higher value in the observable versions.

T A B L E 5 COSMIC function point counts for observable (Ob.) and unobservable (Un.) version of the application, with evaluation of
variance of observable with respect to unobservable architectures (Var.) across the types of data movement counts in the COSMIC taxonomy
(col. 1)
CS+MVC

SOA

Client side

Server side

COSMIC FP

Ob

Un

Var

Ob

Un

Var

Ob

Un

Var

Entry

58

32

+81

35

22

+50%

9

6

+50%

Exit

35

35

+0%

14

14

+0%

2

2

+0%

Read

1

0

-

1

0

-

2

1

+100%

Write

17

0

-

8

0

-

3

1

+150%

2146

ALONGI et al.

T A B L E 6 Lines of code
CS-server side

CS-client side

SOA

MVC

1920

2122

754

oMVC

2437

2897

1461

% diff

26.9

36.5

93.7

The functional processes that are directly mapped to the functional requirements FR1 and FR2 are: log recording,
database/state reading/writing and database/state reconstruction. The mapping between the functional requirements
and the processes is defined as follows: FR1 implies log recording, database(SOA)/state(CS) reading/writing, and
database(SOA)/state(CS) reconstruction; while FR2 implies database(SOA)/state(CS) reading/writing.
It should be noted that our counts and the simplistic nature of our case-study make these estimations very optimistic,
and therefore the connected figures are likely to be much higher in a more complex architecture. In summary, in the
scope of RQ1, the following results:
Observability costs: Observable architectures are bound to be more costly to design and implement; conservatively, increasing costs can amount to at least a factor >0.5 in at least 50% of the COSMIC function types.
Consequently, this finding indicates that a new architecture trade-off analysis61 needs to be instrumented which features of service-level agreements62 such as service-disruption costs, service discontinuity times62 with the dimensions
connected to observability, costs, and required efforts.

6.2

Impacts of observability-by-design

To answer RQ2 we first present in Table 6 an overview of the Lines of Code (LOC) of both case studies, CS-based and
SOA-based, showing the additional effort required to implement the observability-by-design pattern. While in the CS case
study the additional effort is less than 40% and in line with the expectation observed in Table 5, for the SOA application
the effort increase is close to 100%. This difference can be explained by the distributed nature of the SOA application
requiring extra effort to add observability features.

6.2.1

Maintainability

Using CodeMR we have then analyzed both case studies in terms of well-known software architecture metrics, that is,
Complexity, Size, Coupling and Lack of cohesion. We found our analysis on those metrics as they can be used as a significant
measure of the effort needed to maintain a software artifact.
In this respect, we recall the definition of maintainability that has been adopted by ISO 9126:63,64 ‚Äúthe ease with which
a software system or component can be modified to correct faults, improve performance or other attributes, or adapt
to a changed environment [ ‚Ä¶ ]‚Äù Figures 7 and 8 show the relative percentages of classes with metrics‚Äô values low and
low-medium(-high) implemented in both the CS and SOA applications, for the observable and the standard patterns. We
can compare results for Lack of cohesion metric in the SOA case, in both the measures; whereas, we observe a slightly
higher percentage of classes with low values in the CS case. For Size metric, we observe a slightly higher percentage of
classes with low-medium value for the standard pattern in the SOA case, while all the other percentages are comparable.
A specular situation can be observed for Coupling, while for Complexity, we observe in both applications that the standard
pattern presents a higher percentage of classes with medium values.
Observability versus maintainability: Changing the case study and the architectural pattern does indeed
impact the effort needed to assure observability in terms of LOC, but *does not* impact significantly on maintainability.

ALONGI et al.

2147

FIGURE 7

Aggregated metrics: the SOA case

FIGURE 8

Aggregated metrics: the CS case

A careful analysis of our proposed architecture points out that the following two qualities of Maintainability are
mainly eased by an observable architecture. The first quality is the Analizability which consists of ‚Äúthe aspects that
help predict the maintainer or user‚Äôs spent effort (or resources) in trying to diagnose deficiencies and causes of failure
or for identifying parts to be modified in the system‚Äù. In this scope, an observable architecture fosters Activity recording (‚Äúa measure of how thoroughly the system status is recorded‚Äù), Audit trail capability, Failure analysis capability
and Status monitoring capability (‚Äúa measure of how easy it is, of the ability for a user (or maintainer) to identify the
specific operation that caused a failure, and to get monitored data for operations that cause failures during the actual
operation of the system‚Äù). The isolation of the entity State, which captures the (projection of) application‚Äôs state, and

2148

ALONGI et al.

the Logger abstraction, which provides the functionality for recording a declarative representation of it every time
an action is triggered, are essential to allow for improving these aspects. In addition, the availability of a representation of a cause-effect relation between changes of the State and Actions, reduces the effort needed to analyze the
application runtime, hence simplifying error identifications and problem diagnosis. Given the nature of actions, that
is, ‚Äúmessages‚Äù signaling the occurrence of an internal or external relevant event, and given that every Action is handled by using suitable policies, application failures can be easily mapped to Actions, and error handling procedure
be implemented through specific policies. Getting data that concerns failures is as doable as defining suitable actions
that identify architecture failures, and that are enriched with runtime information about them (actions can convey
contextual data).

6.2.2

Changeability

The second quality concerns Changeability which is ‚Äúthe aspects that help predict the maintainer‚Äôs or user‚Äôs effort when
trying to implement a specified modification to the system‚Äù. In particular, the Modification complexity is the reference
quality in the evaluation as it ‚Äúmeasures how easily a maintainer can change the software‚Äù. Observable architectures
impose a precise scheme for implementing the business logic of an application and the use of a precise set of abstractions. These abstractions have precise and unambiguous definitions and follow a fixed structure, so that the developer
interacts with them predictably. A rigorous relationship between the business logic and the abstractions required to
implement it eases the maintenance efforts needed for the architecture and, hence, improves the overall maintainability
of the software product.
Finally, the last quality concern to mention is Reusability (considered in ISO/IEC 25010) which is ‚Äúthe ability of
the software components to be used in developing more than one software product or other assets‚Äù. Adopting patterns
in the architecture definition promotes component reuse, especially for components implementing specific functionalities of Policies through the Command pattern. Consider, for instance, Policies for handling CRUD operations on
databases, such as UpdateStatePolicy in our oMVC implementation, or data statistics, temporal series analysis, predictive
functionalities, etc.

6.3

Observability versus traceability

Traceability is not defined by ISO 9126, but a definition can still be found in the software engineering community. Two
are the meaning that are commonly used to shape the notion of traceability. In software development, traceability is
‚Äúthe extent to which a team of developers can trace work items across the software development lifecycle (SDLC)‚Äù. In
essence, traceability enables teams to keep track of what is currently under development and what has already been
done. Conversely, a second sense is traceability in software testing. In this context, traceability focuses on tracing tests,
test cases, and results. Based on the common two interpretations of traceability in software engineering, we can claim
that our definition of observability is not an alternative to the common interpretation, rather it is transversal to it, being
ultimately a novel concept.

6.4

Threats to validity

Concerning standard threats to validity frameworks such as Wohlin et al.,65 we in fact encountered and tried to address
several internal and construct validity threats, especially in the scope of the use of COSMIC FP Counting to address
RQ1 or within our case-study. On the one hand, we systematically used Inter-Rater reliability assessment methods every
time conclusion validity was at stake, and what is more, we triangulated also the designers and implementors of the
case-study at hand, to avoid observer bias and similar circumstances. At the same time, the size and complexity of the
prototype case under study was deliberately controlled to ensure an extent of external validity. We consider the simplistic
case under study in this article as an optimistic lower-bound for whatever external considerations should practitioners do regarding to their own practice. Beyond these, a number of additional issues and scope limitations are reported
below.

ALONGI et al.

6.4.1

2149

Lack of quantitative metrics for observability

Although we offered a concise definition of architecture observability, the major limitation connected to it is that observability cannot yet be evaluated numerically as there is not a quantitative architecture-based metric that allows designers to
estimate and detect the observability of an implementation upfront‚Äîother than designing for it explicitly as we did‚Äîand
hence to trade-off over different design options. Again, the effects of observability can only be measured indirectly, for
instance, one can refer to the standard ISO 912664 (like the ones implemented in CodeMR) for the evaluation of some
software qualities that are affected by the implementation of a specific architecture. This limitation we encountered in
previous work still applies, although we plan to address it more head-on with results stemming from the formalization
and experimentations reported in this article.

6.4.2

Implementation complexity

The conclusions and the graphs provided in the previous sections are in line with our previous work and again remark
a generalized negative impact of observability in the lines of code, while for most of the considered metrics the overall
average behavior is comparable. This is again not surprising, however, it remarks that architecture styles do not play a
role in mediating system observability. More specific measurements for architecture-level observability are in order to
proceed in defining and exploring such architecture property.

6.4.3

Proof-of-concept evaluation

As previously stated, the evaluation of the observability in this work has been carried out through an experimental study
involving a proof-of-concept case-study of limited size and controlled characteristics; this focus selection reflects the
nature of our target software constructs, which are relatively simple and small, therefore there is a limited external validity
for this study while measurements should apply to several studies to be conclusive. This avenue deserves further exploration and is planned as future work. More specifically, although in this article we aimed at offering a slightly deeper
analysis beyond previous work and to compare different implementations of more significant but still small and manageable applications. In the future, we plan to enlarge the size and complexity of targeted applications and a larger dataset,
focusing on medium and large applications hosted on GitHub.

7

CO NC LU SION S

Modern software systems feature unprecedented scales and complexity. A way to design for such complexity while coping with the required service continuity aspects around such complex applications‚Äô use is the concept of observability.
Designing for it can leverage on event sourcing, that is, capturing all changes to an application state as a sequence
of events, which could in principle be traced and subsequently analysed. In layman‚Äôs terms, observability reflects the
extent to which a complex software application can manifest its internal workings and operations to the outside world
(e.g., to a specific monitoring technology stack), with the possibility of verifying‚Äîthrough runtime- verification and
trace-checking‚Äîspecific service continuity or quality properties. To progress in the definition and operationalization of
observability at an architecture level, we: (1) provide for a rigorous definition for it and elaborate its required design principles; (2) understand its impact on systems architecture maintenance costs. Our results show that observability yields
an additional effort regarding conventional implementations and mildly affect maintenance and evolvability of software
architectures. The conclusion here is that event sourced observability is in fact a worthwhile investment.
In the future, we aim at specific metrics designed to support observability not only as a binary value but also as a
fuzzified metric to further explore the premises and consequences of observability-by-design. At the same time, we aim
to investigate runtime model-checking facilities compatible with the notions and scope defined in this article.

AU THOR CONTRIBUTIONS
Francesco Alongi: Investigation, software, validation, visualization. Marcello M. Bersani: Conceptualization, formal analysis, methodology, validation, supervision, writing original draft e review. Nicol√≤ Ghielmetti: Investigation,

2150

ALONGI et al.

software, validation, visualization. Raffaela Mirandola: Conceptualization, formal analysis, methodology, validation,
supervision, writing original draft e review. Damian A. Tamburri: Conceptualization, formal analysis, methodology,
validation, supervision, writing original draft e review.
DATA AVAILABILITY STATEMENT
All data is correctly linked in the article in the form of a replication package to encourage replication. Help and aids in
replication of the research can be made available upon request to d.a.tamburri@tue.nl.
ORCID
Damian A. Tamburri

https://orcid.org/0000-0003-1230-8961

REFERENCES
1. Google Chrome Team. The evolution of the web. http://www.evolutionoftheweb.com/
2. Aagedal J√ò. Quality of Service Support in Development of Distributed Systems. PhD thesis. University of Oslo; 2001.
3. Reale A. Quality of Service in Distributed Stream Processing for large scale Smart Pervasive Environments. PhD thesis. University of Bologna,
Italy; 2014.
4. Horvat G, Zagar D, Vlaovic J. Evaluation of quality of service provisioning in large-scale pervasive and smart collaborative wireless sensor
and actor networks. Adv Eng Inform. 2017;33:258-273.
5. Logstash; 2022. https://www.elastic.co/logstash/
6. Dynatrace; 2022. https://www.dynatrace.com/
7. Splunk; 2022. https://www.splunk.com/
8. Grafana; 2022. https://grafana.com/
9. Apache skywalking; 2022. https://skywalking.apache.org/
10. Muller E. Monitoring and observability; 2018. https://theagileadmin.com/2018/02/16/monitoring-and-observability/
11. Splunk. What is observability; 2021. https://www.splunk.com/en_us/data-insider/what-is-observability.html
12. Bass L, Clements P, Kazman R. Software Architecture in Practice. 3rd ed. Addison-Wesley Professional; 2012.
13. Erb B, Kargl F. Combining discrete event simulations and event sourcing. Proceedings of the 7th International Conference on Simulation Tools and Techniques - SIMUTools; 2014:51-55; Institute for Computer Sciences, Social-Informatics and Telecommunications
Engineering, Brussels, Belgium.
14. Han S, Choi JI. V2X-based event acquisition and reproduction architecture with event-sourcing. Proceedings of the 6th International
Conference on Computing and Data Engineering - ICCDE; 2020:164-167; Association for Computing Machinery, New York, NY.
15. Overeem M, Spoor M, Jansen S. The dark side of event sourcing: managing data conversion. Proceedings of the 24th International
Conference on Software Analysis, Evolution and Reengineering - SANER; 2017:193-204; IEEE Computer Society Press, Washington, DC.
16. Bass L, Weber I, Zhu L. DevOps: A Software Architect‚Äôs Perspective. SEI Series in Software Engineering. Addison-Wesley; 2015.
17. Bersani MM, Bianculli D, Ghezzi C, KrsticÃÅ S, San PP. Efficient large-scale trace checking using mapreduce. Proceedings of the 38th
International Conference on Software Engineering - ICSE; 2016:888-898; Association for Computing Machinery, New York, NY.
18. Ganter B, Wille R. Formal Concept Analysis: Mathematical Foundations. Springer-Verlag; 1999.
19. Schewe KD, Thalheim B. Conceptual modelling of web information systems. Data Knowl Eng. 2005;54(2):147-188.
20. Akkermans H, Speel PH, Ratcliffe A. Problem, opportunity, and feasibility analysis for knowledge management: an industrial case study.
Proceedings of the 12th Workshop on Knowledge Acquisition, Modeling and Management - EKAW; 1999:147-188; Springer-Verlag, Berlin,
Heidelberg.
21. Burbeck S. Applications programming in smalltalk-80(TM): how to use model-view-controller (MVC); 1987. http://st-www.cs.uiuc.edu/
users/smarch/st-docs/mvc.html
22. Richards M, Microservices vs. Service-Oriented Architecture. O‚ÄôReilly Media, Inc.; 2016. https://www.oreilly.com/learning/microservicesvs-service-oriented-architecture
23. Tamburri DA, Bersani MM, Mirandola R, Pea G. DevOps service observability by-design: experimenting with model-view-controller.
Proceedings of the 7th European Conference on Service-Oriented and Cloud Computing ‚Äì ESOCC. Volume 11116 of Lecture Notes in
Computer Science; 2018:49-64; Springer-Verlag, Berlin, Heidelberg.
24. Abualkishik AZ, Ferrucci F, Gravino C, et al. A study on the statistical convertibility of IFPUG function point, COSMIC function point
and simple function point. Inf Softw Technol. 2017;86(C):1-19.
25. Ibrahim A. Prediction of quality of service of software applications. Proceedings of the 5th European Conference on Service-Oriented
and Cloud Computing ‚Äì ESOCC. Volume 707 of Communications in Computer and Information Science; 2016:260-273; Springer-Verlag,
Berlin, Heidelberg.
26. Toffetti G, Brunner S, Bl√∂chlinger M, Dudouet F, Edmonds A. An architecture for self-managing microservices. Proceedings of the 1st
International Workshop on Automated Incident Management in Cloud ‚Äì AIMC; 2015:19-24; Association for Computing Machinery, New
York, NY.
27. Galletta A, Carnevale L, Buzachis A, Celesti A, Villari M. A microservices-based platform for efficiently managing oceanographic data.
Proceedings of the 4th International Conference on Big Data Innovations and Applications - Innovate-Data; 2018:25-29; IEEE Computer
Society Press, Washington, DC.

ALONGI et al.

2151

28. Shahin M, Zahedi M, Babar MA, Zhu L. An empirical study of architecting for continuous delivery and deployment. Empir Softw Eng.
2019;24(3):1061-1108.
29. Hu K. Data Observability vs. Software Observability Metaplane; 2021. https://www.metaplane.dev/blog/data-observability-vs-softwareobservability
30. Google, DevOps measurement: monitoring and observability; 2022. https://cloud.google.com/architecture/devops/devops-measurementmonitoring-and-observability
31. Carey S. What is observability? Softw Monitor Steroids. InfoWorld; 2021. https://www.infoworld.com/article/3607980/what-isobservability-software-monitoring-on-steroids.html
32. Kalman RE. Mathematical description of linear dynamical systems. J Soc Ind Appl Math Ser A Control. 1963;1(2):152-192.
33. Eventuate. Solving distributed data management problems in a microservice architecture; 2021. https://eventuate.io/
34. Fielding RT. Architectural Styles and the Design of Network-based Software Architectures. Doctoral dissertation, University of California,
Irvine; 2000.
35. Andrews GR. Paradigms for process interaction in distributed programs. ACM Comput Surv. 1991;23(1):49-90.
36. Taylor RN, Medvidovic N, Anderson KM, et al. A component- and message-based architectural style for GUI software. IEEE Trans Softw
Eng. 1996;22(6):390-406.
37. Cooper K, Peters T. The MVVM pattern; 2012. https://msdn.microsoft.com/en-us/library/hh848246.aspx
38. Taligent I. MVP: model-view-presenter; 1996. Taligent, Inc; 1996. http://www.wildcrest.com/Potel/Portfolio/mvp.pdf
39. Fowler M. Event sourcing; 2021. https://martinfowler.com/eaaDev/EventSourcing.html
40. Narumoto M, Buck A, Peterson N, et al. Event sourcing pattern; 2021. https://docs.microsoft.com/en-us/azure/architecture/patterns/
event-sourcing.
41. Richardson C. Pattern: event sourcing; 2021. https://microservices.io/patterns/data/event-sourcing.html.
42. Narumoto M. Command query responsibility segragation; 2021. https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs
43. Fowler M. Command query responsibility segragation; 2021. https://martinfowler.com/bliki/CQRS.html
44. Debski A, Szczepanik B, Malawski M, Spahr S, Muthig D. A scalable, reactive architecture for cloud applications. IEEE Softw.
2018;35(2):62-71.
45. Atlee JM, Gannon JD. State-based model checking of event-driven system requirements. IEEE Trans Softw Eng. 1993;19(1):24-40.
46. Kiczales G, Lamping J, Mendhekar A, et al. Aspect-oriented programming. Proceeding of the 11th European Conference on
Object-Oriented Programming ‚Äì ECOOP. Volume 1241 of Lecture Notes in Computer Science; 1997:220-242; Springer-Verlag, Berlin,
Heidelberg.
47. Microsoft. Azure; 2021. https://azure.microsoft.com
48. Apache. Apache Kafka; 2021. https://kafka.apache.org/
49. Eventuate. Eventuate local; 2021. https://github.com/eventuate-local/eventuate-local/
50. Taylor RN, Medvidovic N, Dashofy EM. Software Architecture: Foundations, Theory, and Practice. Wiley Publishing; 2009.
51. Paolone G, Marinelli M, Paesani R, Felice PD. Automatic code generation of MVC web applications. Computers. 2020;9(3):56.
52. Huang Z, Liang Y. Research of data mining and web technology in university discipline construction decision support system based on
MVC model. Library Hi Tech. 2020;38(3):610-624.
53. Avizienis A, Laprie J, Randell B, et al. Fundamental Concepts of Dependability. University of Newcastle upon Tyne, Computing Science;
2001.
54. Gamma E, Helm R, Johnson R, Vlissides J, Design patterns: elements of reusable object oriented software; 1995.
55. Capers J. Function points as a universal software metric. ACM SIGSOFT Softw Eng Notes. 2013;38(4):1-27.
56. Hira A, Boehm BW. Using software non-functional assessment process to complement function points for software maintenance. Proceedings of the 10th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement - ESEM; 2016:1-6; Association
for Computing Machinery, New York.
57. Krippendorff K. Content Analysis: An Introduction to Its Methodology. 4th ed. Sage Publications; 2018.
58. Appendix of the paper, April 2022. https://www.dropbox.com/sh/2hdvl3o3qzzik6c/AAC4so_ZcNXZrEdoJXZ3Nv6Sa?dl=0
59. Gui G, Scott PD. Measuring software component reusability by coupling and cohesion metrics. J Comput. 2009;4(9):797-805.
60. Dhama HS. Quantitative models of cohesion and coupling in software. J Syst Softw. 1995;29(1):65-74.
61. Bellomo S, Gorton I, Kazman R. Toward agile architecture: insights from 15 years of ATAM data. IEEE Softw. 2015;32(5):38-45.
62. Ghezzi C, Guinea S. Run-time monitoring in service-oriented architectures. In: Baresi L, Di Nitto E, eds.Test and Analysis of Web Services.
Springer; 2007:237-264.
63. IEEE Standard Glossary of Software Engineering Terminology. IEEE Std 61012-1990; Vol. 12, 1990:1-84.
64. Software Engineering ‚Äì Product Quality ‚Äì Part 1: Quality Model. International Organization for Standardization; 2001.
65. Wohlin C, Runeson P, H√∂st M, Ohlsson MC, Regnell B. Experimentation in Software Engineering. Springer-Verlag; 2012.

How to cite this article: Alongi F, Bersani MM, Ghielmetti N, Mirandola R, Tamburri DA. Event-sourced,
observable software architectures: An experience report. Softw Pract Exper. 2022;52(10):2127-2151. doi:
10.1002/spe.3116

