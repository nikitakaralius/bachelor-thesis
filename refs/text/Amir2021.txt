2021 IEEE 45th Annual Computers, Software, and Applications Conference (COMPSAC)

Towards Concurrent Audit Logging in
Microservices
Sepehr Amir-Mohammadian

Afsoon YouseÔ¨Å Zowj

Dept. of Computer Science
University of the PaciÔ¨Åc
Stockton, CA, USA
samirmohammadian@paciÔ¨Åc.edu

Dept. of Computer Science
University of the PaciÔ¨Åc
Stockton, CA, USA
ayouseÔ¨Åzowj@paciÔ¨Åc.edu

the semantic framework of audit logging is used to deÔ¨Åne
an implementation model for linear process execution [5].
Using this implementation model, for instance, audit logging
capability is considered as an extension to a medical records
system (MRS), where all preconditions for logging depend on
the events that transpire in the same program execution thread.
Recently, an implementation model has been proposed for
concurrent systems, where logging an event may be conditioned on the occurrence of events in one or more concurrent components [6]. This model proposes an algorithm to
instrument concurrent systems that are speciÔ¨Åed in a process
calculus, and any instrumented system provably guarantees
correct audit log generation. The algorithm receives a formal
speciÔ¨Åcation of audit logging requirements along with the
source concurrent system as input. This speciÔ¨Åcation uses
Horn clauses to assert which events should be logged as well
as the preconditions to log those events. Using Horn clauses
is helpful in actual implementations, since it facilitates to use
off-the-shelf logic programming tools.
In this paper, we discuss one such implementation of the
instrumentation algorithm for concurrent systems, based on
the aforementioned model. Our tool receives the source code
of a microservices-based application as input, along with a
speciÔ¨Åcation of logging requirements in JSON format. The
application is assumed to be deployed in Java Spring framework. The tool parses the JSON speciÔ¨Åcation of requirements
and translates them to Horn clauses that are supplied to a logic
programming engine. It then instruments the application with
audit logging capabilities. The instrumented application communicates with the logic programming engine in appropriate
places to infer what to log.
In recent years, there has been a growing trend toward the
deployment of applications with microservices architecture.
For example, microservices-based healthcare is anticipated to
experience considerable increase in market value in near future
[7]. In this architecture, the system is decomposed into a set of
loosely-coupled, minimal and Ô¨Åne-grained processes that are
executed independently and collaboratively. Each microservice
has its own back-end database and can be executed in its own
container or machine. Communication between microservices
is usually done through message passing, in particular using
RESTful APIs. Microservices come with several advantages

Abstract‚ÄîInformation-algebraic models have been shown as
effective semantic frameworks in the speciÔ¨Åcation of audit logging
requirements. These semantic frameworks underlie implementation models that formally guarantee correctness of audit logs.
Recently, one such implementation model has been proposed for
concurrent systems. In this paper, we study the deployment of an
instrumentation tool based on this implementation model, aiming
at microservices-based applications that are built by Java Spring
framework. This tool instruments these applications according to
a given logging speciÔ¨Åcation, described in JSON. A set of events
in one or more microservices may necessitate the generation
of log entries in a speciÔ¨Åc microservice. Instrumentation of an
application enables different microservices of that application to
concurrently generate audit logs.
Index Terms‚ÄîAudit logs, concurrent systems, microservices,
programming languages, security

I. I NTRODUCTION
InsufÔ¨Åcient audit logging has been a major application
security problem. Proper monitoring of security-critical events
in an application can potentially mitigate major data breaches.
Open Web Application Security Project has identiÔ¨Åed insufÔ¨Åcient logging and monitoring as one of the top ten security
risks in the web [1], and Common Weakness Enumeration system recognizes it as a recurrent problem in software security
[2]. In addition, efÔ¨Åciency of audit logging plays a crucial role
in system performance. EfÔ¨Åcient audit logging entails to only
record what is necessary for a posteriori analysis and recovery,
rather than naively collecting excessive information in the log
that hinders timely response to security incidents [3].
In this regard, an information-algebraic [4] semantic framework has been proposed to deÔ¨Åne audit logging correctness
[5], which ensures to record factual, necessary and sufÔ¨Åcient
data in the log, and thus avoids both insufÔ¨Åcient and excessive
logging. This is accomplished by comparing the information
contained in the log and the information that must be in the
log. The latter refers to the speciÔ¨Åcation of audit logging
requirements. These speciÔ¨Åcations recognize what must be
logged, given an execution trace. This way, the semantic
framework supports the separation of policy from programs,
which underlies program instrumentation techniques to implement audit logging on legacy systems.
Different implementation models of correct audit logging
have been proposed with provable guarantees. For example,

978-1-6654-2463-9/21/$31.00 ¬©2021 IEEE
DOI 10.1109/COMPSAC51774.2021.00191

1357

‚àÄt0 , ¬∑ ¬∑ ¬∑ , tn , xs0 , ¬∑ ¬∑ ¬∑ , xsn . Call(t0 , A0 , B0 , xs0 )










t0 ‚àß œï(t0 , ¬∑ ¬∑ ¬∑ , tn ) ‚àß œï (xs0 , ¬∑ ¬∑ ¬∑ , xsn ) =‚áí LoggedCall(A0 , B0 , xs0 )



  

Fig. 2: LS call clause structure.

Authorization
CL (Authorization)(breakTheGlass) = [breakTheGlass
 P ] for some P

 

 



CL (Patient)(getMedicalHistory) = [getMedicalHistory

  
 

n 

Call(ti , Ai , Bi , xsi ) ‚àß ti <

i=1




Patient

 Q] for some Q

‚àÄt0 , t1 , p, u . Call(t0 , Patient, getMedicalHistory, [p, u]) ‚àß

 
  

Call(t1 , Authorization, breakTheGlass, [u]) ‚àß t1 < t0 =‚áí
LoggedCall(Patient, getMedicalHistory, [p, u])

Fig. 3: Example logging speciÔ¨Åcation for an MRS.
Fig. 1: An Example MRS.

includes top-level agents A that correspond to the concurrent
components of the system, and sub-agents B of top-level
agents A, denoted by B A . Top-level agents are supposed to
execute in parallel and occasionally communicate with each
other to accomplish their own tasks, and in aggregate the
concurrent system. Sub-agents are treated as internal modules,
procedures, or functions of a top-level agent. The existence of
universal codebase CU and local codebase CL are assumed
that respectively consist of top-level agent deÔ¨Ånitions of the
form A(x1 , ¬∑ ¬∑ ¬∑ , xn )  P , and sub-agent deÔ¨Ånitions of the
form B A (x1 , ¬∑ ¬∑ ¬∑ , xn )  P , where P is a œÄ-calculus process.

including better maintainability, testing, and adaptation to
newer technologies, and thus improved security and fault tolerance. In today‚Äôs world, microservice deployment is supported
by several conventional programming languages.
Example: Microservices-based MRS. As an example, consider an MRS with microservices architecture. An MRS may
include different microservices to accomplish different tasks.
Figure 1 depicts an oversimpliÔ¨Åed system consisting of a frontend service, an authorization service, and a patient service
among other services. Application front-end includes API
gateway that relays requests from clients to back-end services,
using certain proxies. Patient service handles patient data, and
authorization service manages different operations related to
controlling access to system resources. One such operation is
breaking the glass [8]. This operation is used in critical cases
to bypass access control. Breaking the glass requires the users
who run this operation to be accountable for their actions, i.e.,
certain actions of the users who bypass access control need be
recorded in the log for postfacto accountability analyses. One
such action could be reading patient medical history. Indeed,
this simple example demonstrates an audit logging requirement where the event to be logged in a given component of
the concurrent system is conditioned on a preceding event
that belongs to another component. The former event refers
to reading patient medical history in patient microservice, and
the latter event refers to breaking the glass in authorization
microservice. We will return to this example throughout the
paper, as we explore the model and its deployment.
Paper outline. The rest of the paper is organized as follows.
In Section II, we review the formal process-algebraic implementation model. In Section III, we discuss our tool to instrument microservices in Java Spring. In addition, we present a
demo of a microservices-based MRS and its instrumentation
by our tool. Related work is discussed in Section IV. Finally,
Section V concludes the paper.

B. A Class of Logging SpeciÔ¨Åcations
Horn clause logic is used to specify audit logging requirements in this implementation model. In particular, a
class of speciÔ¨Åcations is considered that reÔ¨Çects on timebased relations among different events of a concurrent system,
meaning that a particular event must be logged as long as
certain set of events, in potentially different components of
the concurrent system, have already taken place. These events
may need to satisfy certain properties, e.g., following certain
ordering in time, etc. This class of speciÔ¨Åcations is denoted
by LS call , in which each event is an invocation of an agent
module, i.e., a sub-agent. LS call includes a set of Horn clauses
of the form given in Figure 2, where Call(t, A, B, xs) speciÔ¨Åes
the event of invoking sub-agent B A at time t with list of
parameters xs. œï(t0 , ¬∑ ¬∑ ¬∑ , tn ) is a possibly empty conjunctive
sequence of literals of the form ti < tj . A0 is called a
logging event agent, whereas other Ai s are called trigger
agents. Similarly, logging event sub-agent refers to B0 , and
other Bi s are called trigger sub-agents. Logging preconditions
are predicates Call(ti , Ai , Bi , xÃÉ) for all i ‚àà {1, ¬∑ ¬∑ ¬∑ , n}.
As an example, consider the microservices-based MRS,
described in Figure 1. Each microservice is an agent in
Œ†, including Authorization and Patient services. These
agents may respectively include modules to break the glass
and read patient medical history, which are deÔ¨Åned as part
of CL (Figure 3). Moreover, Figure 3 describes the logging
speciÔ¨Åcation in LS call that is associated with the break-theglass policy. In this clause, t0 and t1 are timestamps, and t1
precedes t0 . p refers to the patient identiÔ¨Åer, and u is the
user identiÔ¨Åer who breaks the glass and attempts to read the
medical history of p later on.

II. I MPLEMENTATION M ODEL
Our instrumentation tool follows a concurrent audit logging
model with correctness guarantees. In this section, we brieÔ¨Çy
review this model. The reader is referred to [6] for the full
formalization and correctness results of this model.
A. Source System Model

C. Target System Model

The source system calculus, denoted by Œ†, relies on a
variant of œÄ-calculus [9] to specify concurrent systems. Œ†

The target system model, denoted by Œ†log , is an extension to Œ†. The instrumentation algorithm maps a Œ† sys-

1358



Authorization
CL (Authorization)(breakTheGlass) = breakTheGlass
(u) 

tem to a Œ†log system. Œ†log is extended with four preÔ¨Åxes:
callEvent(A, B, xÃÉ), addPrecond(x, A), sendPrecond(x, A)
and emit(A, B, xÃÉ), in which xÃÉ is considered as a single list
of names. The runtime environment is also extended with
four components: 1) timing counter t, 2) mapping Œî(¬∑) from
agent A to the set of logging preconditions that denote the
events transpired locally in A, 3) mapping Œ£(¬∑) from logging
event A to the set of all logical preconditions that have
taken place in A‚Äôs trigger agents√ü (these preconditions must
be communicated between A and all trigger agents), and 4)
mapping Œõ(¬∑) from A to the audit log recorded by A.
callEvent(A, B, xÃÉ) updates Œî(A) with predicate
Call(t, A, B, xÃÉ). addPrecond(x, A) updates Œ£(A) with
precondition x. sendPrecond(x, A) converts Œî(A) to a
transferable object and sends it though link x. Finally,
emit(A, B, xÃÉ) studies the derivability of LoggedCall(A, B, xÃÉ)
and accordingly Œõ(A) is updated with this predicate.

callEvent(Authorization, breakTheGlass, [u]).P




Patient

(p, u) 
CL (Patient)(getMedicalHistory) = getMedicalHistory
callEvent(Patient, getMedicalHistory, [p, u]).c¬Ø
PA .cPA (f ).addPrecond(f, Patient).
emit(Patient, getMedicalHistory, [p, u]).Q




CL (Authorization)(DPA ) =

 Authorization

Authorization
D PA
(cPA )  cPA .sendPrecond(cPA , Authorization).D PA
(cPA )

Fig. 4: Example Instrumentation of the MRS.

based on different logging speciÔ¨Åcations. In our instrumentation tool, each microservice of an application is treated as an
agent of the concurrent system, whereas each method deÔ¨Åned
in some library of a microservice is considered as a sub-agent.
A. Instrumentation Tool: LogInst
We have implemented the proposed algorithm I for
microservices-based applications that are deployed using Java
Spring Framework. Our instrumentation tool [10], LogInst,
receives a logging speciÔ¨Åcation along with an application
consisting of two or more microservices, and rewrites those
microservices accordingly. LogInst extends microservices
with required RESTful APIs that facilitate the communication
between microservices for the sake of audit logging.
The logical speciÔ¨Åcation of logging requirements (Section
II-B) is passed as an argument to LogInst in JSON format. LogInst parses this JSON Ô¨Åle and extracts logging
speciÔ¨Åcation in the form of Horn clauses, along with identifying triggers and logging events. The paths to different
microservices of the application are also passed to LogInst.
LogInst applies modiÔ¨Åcations to each microservice component according to the logging speciÔ¨Åcation. In addtion, the path
to the Prolog engine must be fed to LogInst. LogInst uses
SWI Prolog [11] to logically infer the derivation of logging
events according to the logging speciÔ¨Åcation, the set of facts
regarding trigger events, etc.
LogInst uses aspect-oriented programming (AOP), in
particular AspectJ, to weave concurrent logging capability into
microservices. For this purpose, LogInst extends the Project
Object Model of the microservices which need to be instrumented by spring-boot-starter-aop dependency.
According to the implementation model, the conÔ¨Åguration
of the concurrent system includes three different structures to
store the logging preconditions that are transpired locally (Œî),
logging preconditions that are originated remotely (Œ£), and the
audit logs recorded by an agent (Œõ). These structures are added
by LogInst as repositories of logical facts that are kept on
nonvolatile memory. If a microservice is only a trigger, then
a repository is added to that microservice to store logging
preconditions that take place locally in that microservice.
However, if a microservice is a logging event, then that
microservices is extended with all three types of repositories.
We call these repositories local-db, remote-db, and
log-db, resp. Note that according to the deÔ¨Ånition of I
(Section II-D), a trigger is only concerned with locally transpired preconditions (through callEvent preÔ¨Åxes), whereas a
logging event needs to access all three types of aforementioned
structures (through callEvent, addPrecond, and emit preÔ¨Åxes).

D. Instrumentation Algorithm
Instrumentation algorithm I takes a Œ† system and a logging speciÔ¨Åcation from LS call , and produces a Œ†log system
with the following details. I adds fresh links cij between
every logging event agent Ai and trigger agent Aj , in order
to communicate logging preconditions (by sendPrecond and
addPrecond preÔ¨Åxes). If sub-agent B A is a trigger, then its
execution must be preceded by callEvent preÔ¨Åx, so that the
logging precondition is stored in Œî(A). If sub-agent B A is a
logging event agent, the execution of B A must be preceded
by callEvent, similar to the previous case. Next, it must
communicate on appropriate links (cij s) with all trigger agents.
To this end, B A is supposed to notify each of those agents to
send their collected preconditions, and then it must add them
to Œ£(A). This is done using addPrecond preÔ¨Åxes. Then, it
should study whether the invocation needs to be logged, before
following normal execution. This is facilitated by emit preÔ¨Åx.
If Aj is a trigger agent then it must be able to handle
incoming requests for collected preconditions. This is done by
adding a fresh sub-agent to Aj that always listens for requests
on the dedicated link (cij ) between itself and the logging event
agent. This sub-agent is denoted by Dij . Upon receiving such
a request, Dij sends back the preconditions, handled by preÔ¨Åx
sendPrecond, and then continues to listen on cij .
As an example consider the instrumentation of the MRS
described in Figures 1 and 3. According to the logging speciÔ¨Åcation, getMedicalHistoryPatient is the logging event,
and breakTheGlassAuthorization is the only trigger. I instruments the system as described in Figure 4. A new link
cPA is established between the two agents, and sub-agents are
instrumented accordingly. In addition, sub-agent DPA is added
to Authorization microservice that indeÔ¨Ånitely responds to
the requests from Patient microservice on cPA .
III. I NSTRUMENTING M ICROSERVICES
In this section, we explain the implementation of the instrumentation algorithm for microservices-based applications, as
well as a demo of how the tool modiÔ¨Åes these applications

1359

I extends every trigger with sub-agents, Dij , that send back
the locally generated preconditions upon receiving a request
on a dedicated link (using sendPrecond preÔ¨Åx). LogInst
implements this feature by extending each trigger microservice with a REST controller that sends back the content
of local-db, if it receives an HTTP GET request on the
dedicated path /localdb. This controller is denoted by
LocalDBController, henceforth. On the other side, a
logging event microservice is supposed to contact the trigger
on dedicated links to receive the preconditions that are transpired in trigger agents. LogInst facilitates this by extending
every logging event microservice with a web client that sends
asynchronous HTTP GET requests to /localdb path on
trigger microservices and collects the responses. We have
called this service RestClient.
As mentioned earlier, AOP is used to add logging capabilities to microservices. For this purpose, LogInst identiÔ¨Åes the
pointcuts in which an advice needs to be deÔ¨Åned. According to
I, trigger sub-agents are preceded by callEvent preÔ¨Åxes. For
this purpose, LogInst deÔ¨Ånes before aspects for each of the
trigger methods, where the advice includes the construction
of preconditions from the join points and adding them to
local-db. This implements the semantics of callEvent.
I instruments logging event sub-agents by inserting a sequence of operations before the execution of these sub-agents.
This sequence includes callEvent preÔ¨Åxes, communication
on dedicated links to receive remotely transpired logging
preconditions, adding them to Œ£ using addPrecond preÔ¨Åxes,
and Ô¨Ånally checking if logging events should to be logged,
using emit. LogInst handles this by deÔ¨Åning before aspects
for the pointcuts that correspond to logging event methods.
Similar to the aspects deÔ¨Åned for trigger methods, the advice
for logging event methods starts with the construction of preconditions from join points and adding them to local-db.
Next, RestClient is used to asynchronously send an HTTP
GET request on the predeÔ¨Åned path /localdb to each of the
trigger microservices, and collect the results in remote-db.
This implements the semantics of addPrecond preÔ¨Åx. Then,
SWI Prolog engine is invoked to add the logging speciÔ¨Åcation,
and the contents of local-db and remote-db. Finally, the
Prolog engine is queried to study if the invocation of logging
event must be logged, and accordingly log-db repository
is updated. These Ô¨Ånal steps implement the semantics of
emit preÔ¨Åx. In order to facilitate the communication between
SWI Prolog engine and Java Virtual Machine, InterProlog
Java/Prolog SDK [12] is used.
Figure 5 speciÔ¨Åes the advice for triggers and logging events
in general form. Figure 7a depicts some of the aforementioned
modiÔ¨Åcations that LogInst applies architecturally to the
logging event and trigger microservices.

@Before("execution (some trigger)")
public void someAspect(JoinPoint){
...
build precondition from JoinPoint
add precondition to local-db
...
}
@Before("execution (some logging event)")
public void someAspect(JoinPoint) {
...
build precondition from JoinPoint
add precondition to local-db
...
send GET to triggers
collect the responses in remote-db
...
add logging specification to the engine
add the content of local-db to the engine
add the content of remote-db to the engine
query the engine and update log-db
...
}

Fig. 5: Pseudocode of before advice for triggers and logging events.

front-end microservice of MRSDemo authenticates users and acts
as the API gateway by relaying requests to the back-end
microservices.
In the following, we explain how MRSDemo is instrumented
by LogInst for a given logging speciÔ¨Åcation. In Figure 3, we
have described a logging speciÔ¨Åcation that enforces logging
access to patient medical history at any point after breaking
the glass. We can assert a similar logging speciÔ¨Åcation rule in
JSON [10] , which is more verbose than its logical equivalent.
LogInst parses that JSON speciÔ¨Åcation and constructs the
Horn clause given in Figure 6 (ver. 1), which is then added
to SWI Prolog engine fact base. Note that in this Horn clause
presentation, we have redacted the full package names of the
trigger and logging event methods and replaced them with
<package>, for the sake of space economy. LogInst
instruments MRSDemo according to this logging speciÔ¨Åcation
rule as follows: spring-boot-starter-aop dependency
is added to the POM of Patient and Authorization services.
Authorization service is extended with local-db.
Patient service is extended with local-db, as well
as remote-db, and log-db. Authorization service is
extended with the REST controller LocalDBController
that responds to requests on path /localdb. Patient
service is extended with RestClient web client. A
before aspect is added to Authorization service with
AuthorizationController.breakTheGlass
as its pointcut. This aspect builds preconditions from
the join point and appends them to local-db. A
before aspect is added to Patient service with pointcut
PatientController.getPatientMedHistByName,
to 1) build preconditions from the join point and append
them to local-db, 2) send HTTP GET request on path
/localdb to Authorization service, and store the results in
remote-db repository, 3) add the logging speciÔ¨Åcation, and
contents of local-db and remote-db repositories to the
SWI Prolog engine, and 4) send queries to the Prolog engine
to check derivability of loggedfunccall predicates and
accordingly update log-db with the engine‚Äôs response.
These changes describe the real-world instrumentation of
the MRS, formally given in Figure 4. Note that Authentication
microservice is unaffected when instrumented by LogInst,
as it does not include any trigger or logging event methods

B. Case Study: Instrumenting MRSDemo with LogInst
In Section I, we discussed an oversimpliÔ¨Åed MRS consisting of several loosely-coupled microservices. We have
implemented [13] a demo of this system, MRSDemo , consisting
of several microservices, using Java Spring Boot [14]. The

1360

enforcible logging policies. There have been other approaches
to deÔ¨Åne semantics of microservices, including Petri nets [28].
Formal study of audit logging. One line of work wrt formal
study of audit logging focuses on the security of logs, in
particular through cryptographic techniques, e.g., to establish
forward secrecy [29], to ensure trustworthiness of logs [30],
[31], and to preserve privacy in auditing [32]. These techniques
assume that logs are given in the Ô¨Årst place to be secured.
However, in this paper we aim at developing a tool to generate
audit logs according to a provably correct model, and thus
security of the logged data is orthogonal to it.
Another line of work uses logical frameworks to establish
accountability in access to system resources. Examples include
a framework to enforce accountability goals in discretionary
access control [33], accountability wrt access to personal information based on owner-deÔ¨Åned usage policies [34], distributed
accountability based on turn-based games [35], and logging the
proof of having access to system resources [36], [37]. Another
related area of work is the language-level analysis of generated
audit logs [38], [39].
Correct audit logging. Information algebra [4] has been
used to describe the semantics of audit logging [5] for linear
process execution that deÔ¨Ånes notion of correctness for audit
logs, along with an instrumentation model that guarantees
to generate correct audit logs. Lately, an instrumentation
model has been proposed for concurrent systems based on
the information-algebraic semantic framework [6]. This model
enjoys correct audit logging, which has been the basis for our
proposed instrumentation tool.
Provenance. Audit logging is closely associated with the
notion of provenance tracking [40]‚Äì[42]. Recent works in this
area include ClearScope [43] a provenance tracker for Android
devices, CamFlow [44] an auditing and provenance capture
utility in Linux, and AccessProv [45] an instrumentation tool
to discover vulnerabilities in Java applications.

/* Version 1 */
loggedfunccall(T0, patient-service,
"<package>.PatientController.getPatientMedHistByName", [U, P]) :funccall(T0, patient-service,
"<package>.PatientController.getPatientMedHistByName", [U, P]),
funccall(T1, authorization-service,
"<package>.AuthorizationController.breakTheGlass", [U]),
<(T1, T0), ==(U, user).
/* Version 2 */
loggedfunccall(T0, patient-service,
"<package>.PatientController.getPatientMedHistByName", [U, P]) :funccall(T0, patient-service,
"<package>.PatientController.getPatientMedHistByName", [U, P]),
funccall(T1, authorization-service,
"<package>.AuthorizationController.breakTheGlass", [U]),
funccall(T2, authentication-service,
"<package>.AuthenticationService.authenticate", [U]),
<(T1, T0), <(T2, T1), ==(U, user).
/* Version 3 */
loggedfunccall(T0, patient-service,
"<package>.PatientController.getPatientMedHistByName", [U, P]) :funccall(T0, patient-service,
"<package>.PatientController.getPatientMedHistByName", [U, P]),
funccall(T1, authorization-service,
"<package>.AuthorizationController.breakTheGlass", [U]),
funccall(T2, patient-service,
"<package>.PatientController.getAllPatients", [U]),
funccall(T3, authorization-service,
"<package>.AuthorizationController.getBTGUsers", []),
<(T1, T0), <(T2, T0), <(T3, T0), ==(U, user).

Fig. 6: Different versions of break-the-glass policy speciÔ¨Åed as a
Horn clause.

according to the logging speciÔ¨Åcation.
The two other versions (Figure 6) are example extensions to
the policy ver. 1 . In ver. 2, authenication is considered as an
additional trigger. Therefore, in addition to the aforementioned
changes, LogInst extends Authentication microservice with
local-db repository, LocalDBController, and a before
aspect (trigger version). The before aspect of Patient microservice is also extended with sending HTTP GET requests to
Authentication microservice on path /localdb, and storing
the results in remote-db. In ver. 3, two additional triggers
are considered in Authorization and Patient microservices.
LogInst applies the same changes given above, along with
deÔ¨Åning before aspects for each extra trigger. Figures 7b and
7c visually describe some of the aforementioned changes
to MRSDemo by LogInst, considering each version of the
policy.These instrumented versions are accessible in [10],
along with other examples of logging speciÔ¨Åcations, and their
associated instrumented counterparts.

V. C ONCLUSION
In this paper, we have proposed a tool, LogInst, to
instrument microservices-based applications that are deployed
in Java Spring Framework for audit logging purposes. Our
tool is based on an implementation model for concurrent
systems that guarantees correctness of audit logging, using
an information-algebraic semantic framework. LogInst receives the application source code, consisting of two or more
microservices, along with a speciÔ¨Åcation of audit logging
requirements in JSON format. LogInst parses the JSON
speciÔ¨Åcation and extracts Horn clauses that are fed to a logic
programming engine. LogInst instruments the microservices
according to this speciÔ¨Åcation. The instrumentation includes
adding new repositories to the corresponding microservices,
extending RESTful APIs on those microservices for loggingrelated communications, and weaving audit logging into the
control Ô¨Çow of microservices using AspectJ. Our case study
is a medical records system in which certain actions in authorization microservice may trigger logging events in access to
patient medical data.

IV. R ELATED W ORK
Audit logging in microservices. In recent years, constructing software in terms of decoupled microservices [15]‚Äì[18]
has been a trending approach in web application design and
deployment, and thus different studies have been conducted
on microservices security [19]‚Äì[21]. In practice, enforcing indepth security has pushed platform-speciÔ¨Åc monitoring and
logging techniques for microservices, e.g., in Azure Kubernetes Service [22] and Spring Security Framework [23],
[24]. One common approach has been to establish a central
logging service with data visualization capabilities [25]. Examples include a provenance logger for microservices-based
applications [26], and an architecture for IoT services that
includes logger microservices in Web of Objects platform
[27]. Our approach in audit logging is concurrent rather than
central, i.e., any microservice is able to log events based
on preconditions that may occur in other microservices as
well as that microservice. This boosts the expressivity of the

1361










































$%&



$%&







$%'






#

#



 
  
$%'

  
















! "




 "







#



  


 

 
  



 
  

! "


 
  






 "







 
  


















  





(b) MRSDemo instrumented by LogInst using (c) MRSDemo instrumented by LogInst using
version 2 in Figure 6.
microservices, instrumented by LogInst. versions 1 and 3 in Figure 6.
Fig. 7: Architecture of microservices after instrumentation.

(a) Structure of the logging event and trigger

R EFERENCES

[24] O. Baker and Q. Nguyen, ‚ÄúA novel approach to secure microservice
architecture from owasp vulnerabilities,‚Äù in CITRENZ (2019).
[25] J. KazanavicÃåius and D. MazÃåeika, ‚ÄúMigrating legacy software to microservices architecture,‚Äù in eStream. IEEE, 2019, pp. 1‚Äì5.
[26] W. Smith, T. Moyer, and C. Munson, ‚ÄúCurator: provenance management
for modern distributed systems,‚Äù in TaPP, 2018.
[27] M. A. Jarwar, S. Ali, M. G. Kibria, S. Kumar, and I. Chong, ‚ÄúExploiting
interoperable microservices in web objects enabled internet of things,‚Äù
in ICUFN. IEEE, 2017, pp. 49‚Äì54.
[28] M. Camilli, C. Bellettini, L. Capra, and M. Monga, ‚ÄúA formal framework
for specifying and verifying microservices based process Ô¨Çows,‚Äù in
SEFM. Springer, 2017, pp. 187‚Äì202.
[29] A. A. Yavuz and P. Ning, ‚ÄúBAF: an efÔ¨Åcient publicly veriÔ¨Åable secure
audit logging scheme for distributed systems,‚Äù in ACSAC, 2009, pp.
219‚Äì228.
[30] B. BoÃàck, D. Huemer, and A. M. Tjoa, ‚ÄúTowards more trustable log Ô¨Åles
for digital forensics by means of ‚Äútrusted computing‚Äù,‚Äù in AINA 2010.
IEEE Computer Society, 2010, pp. 1020‚Äì1027.
[31] R. Accorsi, ‚ÄúBbox: A distributed secure log architecture,‚Äù in EuroPKI,
2010, pp. 109‚Äì124.
[32] A. J. Lee, P. Tabriz, and N. Borisov, ‚ÄúA privacy-preserving interdomain
audit framework,‚Äù in WPES, 2006, pp. 99‚Äì108.
[33] J. G. Cederquist, R. Corin, M. A. C. Dekker, S. Etalle, J. I. den Hartog,
and G. Lenzini, ‚ÄúAudit-based compliance control,‚Äù Int. J. Inf. Secur.,
vol. 6, no. 2-3, pp. 133‚Äì151, 2007.
[34] R. Corin, S. Etalle, J. I. den Hartog, G. Lenzini, and I. Staicu, ‚ÄúA logic
for auditing accountability in decentralized systems,‚Äù in FAST 2004,
2004, pp. 187‚Äì201.
[35] R. Jagadeesan, A. Jeffrey, C. Pitcher, and J. Riely, ‚ÄúTowards a theory
of accountability and audit,‚Äù in ESORICS 2009, 2009, pp. 152‚Äì167.
[36] J. A. Vaughan, L. Jia, K. Mazurak, and S. Zdancewic, ‚ÄúEvidence-based
audit,‚Äù in CSF 2008, 2008, pp. 177‚Äì191.
[37] S. Etalle and W. H. Winsborough, ‚ÄúA posteriori compliance control,‚Äù in
SACMAT 2007, 2007, pp. 11‚Äì20.
[38] F. Bavera and E. Bonelli, ‚ÄúJustiÔ¨Åcation logic and audited computation,‚Äù
J. Log. Comput, vol. 28, no. 5, pp. 909‚Äì934, 2015.
[39] W. Ricciotti and J. Cheney, ‚ÄúStrongly normalizing audited computation,‚Äù
arXiv preprint arXiv:1706.03711, 2017.
[40] W. Ricciotti, ‚ÄúA core calculus for provenance inspection,‚Äù in PPDP.
ACM, 2017, pp. 187‚Äì198.
[41] M. Herschel, R. DiestelkaÃàmper, and H. B. Lahmar, ‚ÄúA survey on
provenance: What for? what form? what from?‚Äù The VLDB Journal,
vol. 26, no. 6, pp. 881‚Äì906, 2017.
[42] P. Buneman and W.-C. Tan, ‚ÄúData provenance: What next?‚Äù ACM
SIGMOD Record, vol. 47, no. 3, pp. 5‚Äì16, 2019.
[43] M. Gordon, J. Eikenberry, A. Eden, J. Perkins, and M. Rinard, ‚ÄúPrecise
and comprehensive provenance tracking for android devices,‚Äù Tech.
Rep., 2019.
[44] T. Pasquier, X. Han, M. Goldstein, T. Moyer, D. Eyers, M. Seltzer,
and J. Bacon, ‚ÄúPractical whole-system provenance capture,‚Äù in SoCC.
ACM, 2017, pp. 405‚Äì418.
[45] F. Capobianco, C. Skalka, and T. Jaeger, ‚ÄúACCESSPROV: Tracking the
provenance of access control decisions,‚Äù in TaPP, 2017.

[1] ‚ÄúTop
10-2017
A10-InsufÔ¨Åcient
Logging
&
Monitoring,‚Äù
https://rb.gy/mj1xpf, 2017, accessed: 2021-03-05.
[2] ‚ÄúCWE-778: InsufÔ¨Åcient Logging,‚Äù https://rb.gy/2hhb5o, 2021, accessed:
2021-04-07.
[3] ‚ÄúCWE-779: Logging of Excessive Data,‚Äù https://rb.gy/myvjgc, 2021,
accessed: 2021-04-07.
[4] J. Kohlas and J. Schmid, ‚ÄúAn algebraic theory of information: An
introduction and survey,‚Äù Information, vol. 5, no. 2, pp. 219‚Äì254, 2014.
[5] S. Amir-Mohammadian, S. Chong, and C. Skalka, ‚ÄúCorrect audit logging: Theory and practice,‚Äù in POST, 2016, pp. 139‚Äì162.
[6] S. Amir-Mohammadian and C. Kari, ‚ÄúCorrect audit logging in concurrent systems,‚Äù ENTCS, vol. 351, pp. 115‚Äì141, September 2020.
[7] ‚ÄúGlobal Microservices In Healthcare Market Will Reach USD 519
Million By 2025,‚Äù https://rb.gy/pi8y7l, 2019, accessed: 2021-04-07.
[8] P. Matthews and H. Gaebel, ‚ÄúBreak the glass,‚Äù in HIE Topic Series.
Healthcare Information and Management Systems Society, 2009.
[9] J. Parrow, ‚ÄúAn introduction to the œÄ-calculus,‚Äù in Handbook of Process
Algebra. Elsevier, 2001, pp. 479‚Äì543.
[10] S. Amir-Mohammadian and A. Y. Zowj, ‚ÄúLogInst: Instrumenting Microservices of Java Web Apps for Auditing,‚Äù https://rb.gy/h5gihs, 2020.
[11] ‚ÄúSWI Prolog,‚Äù https://www.swi-prolog.org/, accessed: 2021-04-15.
[12] M. Calejo, ‚ÄúInterprolog: Towards a declarative embedding of logic
programming in java,‚Äù in JELIA. Springer, 2004, pp. 714‚Äì717.
[13] S. Amir-Mohammadian and A. Y. Zowj, ‚ÄúDemo microservices-based
medical records system (MRS),‚Äù https://rb.gy/fgrtbk, 2020.
[14] P. Webb, D. Syer, J. Long, S. Nicoll, R. Winch, A. Wilkinson,
M. Overdijk, C. Dupuis, and S. Deleuze, ‚ÄúSpring boot reference guide,‚Äù
Part IV. Spring Boot features, vol. 24, 2013.
[15] N. Dragoni, S. Giallorenzo, A. L. Lafuente, M. Mazzara, F. Montesi,
R. MustaÔ¨Ån, and L. SaÔ¨Åna, ‚ÄúMicroservices: yesterday, today, and tomorrow,‚Äù in Present and ulterior software engineering. Springer, 2017, pp.
195‚Äì216.
[16] C. Guidi, I. Lanese, M. Mazzara, and F. Montesi, ‚ÄúMicroservices: a
language-based approach,‚Äù in Present and Ulterior Software Engineering. Springer, 2017, pp. 217‚Äì225.
[17] J. Soldani, D. A. Tamburri, and W.-J. Van Den Heuvel, ‚ÄúThe pains and
gains of microservices: A systematic grey literature review,‚Äù J. Syst.
Software, vol. 146, pp. 215‚Äì232, 2018.
[18] J. Salibindla, ‚ÄúMicroservices api security,‚Äù Int. J. Eng. Res., vol. 7, no. 1,
pp. 277‚Äì281, 2018.
[19] M. McLarty, R. Wilson, and S. Morrison, Securing Microservice APIs.
O‚ÄôReilly Media, Inc., 2018.
[20] P. Nkomo and M. Coetzee, ‚ÄúSoftware development activities for secure
microservices,‚Äù in ICCSA. Springer, 2019, pp. 573‚Äì585.
[21] A. Nehme, V. Jesus, K. Mahbub, and A. Abdallah, ‚ÄúSecuring microservices,‚Äù IT Professional, vol. 21, no. 1, pp. 42‚Äì49, 2019.
[22] M. Wasson, ‚ÄúMonitoring a microservices architecture in Azure Kubernetes Service (AKS),‚Äù https://rb.gy/xzlm95, 2020, accessed: 2021-04-15.
[23] Q. Nguyen and O. Baker, ‚ÄúApplying spring security framework and
oauth2 to protect microservice architecture api,‚Äù Journal of Software,
pp. 257‚Äì264, 2019.

1362

